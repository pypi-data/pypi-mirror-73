#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class PartitionStrategy(object):
    INCREMENTAL = 0
    CUMULATIVE = 1

    _VALUES_TO_NAMES = {
        0: "INCREMENTAL",
        1: "CUMULATIVE",
    }

    _NAMES_TO_VALUES = {
        "INCREMENTAL": 0,
        "CUMULATIVE": 1,
    }


class Operation(object):
    MIN = 0
    MAX = 1
    FIRST = 2
    LAST = 3
    TOP = 4
    BOTTOM = 5
    APPROX_UNIQUE_COUNT = 6
    COUNT = 7
    SUM = 8
    MEAN = 9
    VARIANCE = 10
    SKEW = 11
    KURTOSIS = 12
    APPROX_PERCENTILE = 13

    _VALUES_TO_NAMES = {
        0: "MIN",
        1: "MAX",
        2: "FIRST",
        3: "LAST",
        4: "TOP",
        5: "BOTTOM",
        6: "APPROX_UNIQUE_COUNT",
        7: "COUNT",
        8: "SUM",
        9: "MEAN",
        10: "VARIANCE",
        11: "SKEW",
        12: "KURTOSIS",
        13: "APPROX_PERCENTILE",
    }

    _NAMES_TO_VALUES = {
        "MIN": 0,
        "MAX": 1,
        "FIRST": 2,
        "LAST": 3,
        "TOP": 4,
        "BOTTOM": 5,
        "APPROX_UNIQUE_COUNT": 6,
        "COUNT": 7,
        "SUM": 8,
        "MEAN": 9,
        "VARIANCE": 10,
        "SKEW": 11,
        "KURTOSIS": 12,
        "APPROX_PERCENTILE": 13,
    }


class TimeUnit(object):
    SECONDS = 0
    MINUTES = 1
    HOURS = 2
    DAYS = 3
    WEEKS = 4
    YEARS = 5

    _VALUES_TO_NAMES = {
        0: "SECONDS",
        1: "MINUTES",
        2: "HOURS",
        3: "DAYS",
        4: "WEEKS",
        5: "YEARS",
    }

    _NAMES_TO_VALUES = {
        "SECONDS": 0,
        "MINUTES": 1,
        "HOURS": 2,
        "DAYS": 3,
        "WEEKS": 4,
        "YEARS": 5,
    }


class Query(object):
    """
    Attributes:
     - select
     - where
     - startPartition
     - endPartition
     - timeColumn
     - partitionColumn
     - partitionFormat
     - setups
     - ingestionTimeColumn
     - reversalColumn
     - additionalPartitions
     - partitionLag
    """


    def __init__(self, select=None, where=None, startPartition=None, endPartition=None, timeColumn=None, partitionColumn="ds", partitionFormat="yyyy-MM-dd", setups=[
    ], ingestionTimeColumn=None, reversalColumn=None, additionalPartitions=None, partitionLag=0,):
        self.select = select
        self.where = where
        self.startPartition = startPartition
        self.endPartition = endPartition
        self.timeColumn = timeColumn
        self.partitionColumn = partitionColumn
        self.partitionFormat = partitionFormat
        if setups is self.thrift_spec[8][4]:
            setups = [
            ]
        self.setups = setups
        self.ingestionTimeColumn = ingestionTimeColumn
        self.reversalColumn = reversalColumn
        self.additionalPartitions = additionalPartitions
        self.partitionLag = partitionLag

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.select = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.select[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.where = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endPartition = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.timeColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.partitionColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.partitionFormat = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.setups = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.setups.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.ingestionTimeColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.reversalColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.additionalPartitions = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.partitionLag = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Query')
        if self.select is not None:
            oprot.writeFieldBegin('select', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.select))
            for kiter13, viter14 in self.select.items():
                oprot.writeString(kiter13.encode('utf-8') if sys.version_info[0] == 2 else kiter13)
                oprot.writeString(viter14.encode('utf-8') if sys.version_info[0] == 2 else viter14)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.where is not None:
            oprot.writeFieldBegin('where', TType.STRING, 2)
            oprot.writeString(self.where.encode('utf-8') if sys.version_info[0] == 2 else self.where)
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 3)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.endPartition is not None:
            oprot.writeFieldBegin('endPartition', TType.STRING, 4)
            oprot.writeString(self.endPartition.encode('utf-8') if sys.version_info[0] == 2 else self.endPartition)
            oprot.writeFieldEnd()
        if self.timeColumn is not None:
            oprot.writeFieldBegin('timeColumn', TType.STRING, 5)
            oprot.writeString(self.timeColumn.encode('utf-8') if sys.version_info[0] == 2 else self.timeColumn)
            oprot.writeFieldEnd()
        if self.partitionColumn is not None:
            oprot.writeFieldBegin('partitionColumn', TType.STRING, 6)
            oprot.writeString(self.partitionColumn.encode('utf-8') if sys.version_info[0] == 2 else self.partitionColumn)
            oprot.writeFieldEnd()
        if self.partitionFormat is not None:
            oprot.writeFieldBegin('partitionFormat', TType.STRING, 7)
            oprot.writeString(self.partitionFormat.encode('utf-8') if sys.version_info[0] == 2 else self.partitionFormat)
            oprot.writeFieldEnd()
        if self.setups is not None:
            oprot.writeFieldBegin('setups', TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.setups))
            for iter15 in self.setups:
                oprot.writeString(iter15.encode('utf-8') if sys.version_info[0] == 2 else iter15)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ingestionTimeColumn is not None:
            oprot.writeFieldBegin('ingestionTimeColumn', TType.STRING, 9)
            oprot.writeString(self.ingestionTimeColumn.encode('utf-8') if sys.version_info[0] == 2 else self.ingestionTimeColumn)
            oprot.writeFieldEnd()
        if self.reversalColumn is not None:
            oprot.writeFieldBegin('reversalColumn', TType.STRING, 10)
            oprot.writeString(self.reversalColumn.encode('utf-8') if sys.version_info[0] == 2 else self.reversalColumn)
            oprot.writeFieldEnd()
        if self.additionalPartitions is not None:
            oprot.writeFieldBegin('additionalPartitions', TType.STRING, 11)
            oprot.writeString(self.additionalPartitions.encode('utf-8') if sys.version_info[0] == 2 else self.additionalPartitions)
            oprot.writeFieldEnd()
        if self.partitionLag is not None:
            oprot.writeFieldBegin('partitionLag', TType.I32, 12)
            oprot.writeI32(self.partitionLag)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StagingQuery(object):
    """
    StagingQuery can be used to express free form ETL (including joins/group by) within Zipline. Simple column level
    transformations that don't require joins or aggregations should be expressed as a `Query`.


    Attributes:
     - name
     - query
     - startDate
     - dependencies
     - querySetupCommands
    """


    def __init__(self, name=None, query=None, startDate=None, dependencies=None, querySetupCommands=None,):
        self.name = name
        self.query = query
        self.startDate = startDate
        self.dependencies = dependencies
        self.querySetupCommands = querySetupCommands

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startDate = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dependencies = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.dependencies.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.querySetupCommands = []
                    (_etype25, _size22) = iprot.readListBegin()
                    for _i26 in range(_size22):
                        _elem27 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.querySetupCommands.append(_elem27)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StagingQuery')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.startDate is not None:
            oprot.writeFieldBegin('startDate', TType.STRING, 3)
            oprot.writeString(self.startDate.encode('utf-8') if sys.version_info[0] == 2 else self.startDate)
            oprot.writeFieldEnd()
        if self.dependencies is not None:
            oprot.writeFieldBegin('dependencies', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.dependencies))
            for iter28 in self.dependencies:
                oprot.writeString(iter28.encode('utf-8') if sys.version_info[0] == 2 else iter28)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.querySetupCommands is not None:
            oprot.writeFieldBegin('querySetupCommands', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.querySetupCommands))
            for iter29 in self.querySetupCommands:
                oprot.writeString(iter29.encode('utf-8') if sys.version_info[0] == 2 else iter29)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EventSource(object):
    """
    The underlying data that generates your feature is an event
    with a logical timestamp for when it occurred in the real world,
    and the event is immutable in the underlying source.

    Attributes:
     - table
     - topic
     - query
     - partitionStrategy
    """


    def __init__(self, table=None, topic=None, query=None, partitionStrategy=0,):
        self.table = table
        self.topic = topic
        self.query = query
        self.partitionStrategy = partitionStrategy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.topic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.partitionStrategy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EventSource')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 1)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.topic is not None:
            oprot.writeFieldBegin('topic', TType.STRING, 2)
            oprot.writeString(self.topic.encode('utf-8') if sys.version_info[0] == 2 else self.topic)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 3)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        if self.partitionStrategy is not None:
            oprot.writeFieldBegin('partitionStrategy', TType.I32, 4)
            oprot.writeI32(self.partitionStrategy)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EntitySource(object):
    """
    The underlying data that generates your feature is an entity
    that exists across time - as opposed to an event that occurs
    at a point in time. Each partition of underlying data contains
    a snapshot of these entities and their values as of that day.
    "Dim" DB snapshots are the Quintessential use-case for this source.

    Attributes:
     - snapshotTable
     - mutationTable
     - mutationTopic
     - query
    """


    def __init__(self, snapshotTable=None, mutationTable=None, mutationTopic=None, query=None,):
        self.snapshotTable = snapshotTable
        self.mutationTable = mutationTable
        self.mutationTopic = mutationTopic
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapshotTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mutationTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mutationTopic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EntitySource')
        if self.snapshotTable is not None:
            oprot.writeFieldBegin('snapshotTable', TType.STRING, 1)
            oprot.writeString(self.snapshotTable.encode('utf-8') if sys.version_info[0] == 2 else self.snapshotTable)
            oprot.writeFieldEnd()
        if self.mutationTable is not None:
            oprot.writeFieldBegin('mutationTable', TType.STRING, 2)
            oprot.writeString(self.mutationTable.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTable)
            oprot.writeFieldEnd()
        if self.mutationTopic is not None:
            oprot.writeFieldBegin('mutationTopic', TType.STRING, 3)
            oprot.writeString(self.mutationTopic.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTopic)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 4)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Source(object):
    """
    Attributes:
     - events
     - entities
    """


    def __init__(self, events=None, entities=None,):
        self.events = events
        self.entities = entities

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.events = EventSource()
                    self.events.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.entities = EntitySource()
                    self.entities.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Source')
        if self.events is not None:
            oprot.writeFieldBegin('events', TType.STRUCT, 1)
            self.events.write(oprot)
            oprot.writeFieldEnd()
        if self.entities is not None:
            oprot.writeFieldBegin('entities', TType.STRUCT, 2)
            self.entities.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Window(object):
    """
    Attributes:
     - length
     - timeUnit
    """


    def __init__(self, length=None, timeUnit=None,):
        self.length = length
        self.timeUnit = timeUnit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeUnit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Window')
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 1)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        if self.timeUnit is not None:
            oprot.writeFieldBegin('timeUnit', TType.I32, 2)
            oprot.writeI32(self.timeUnit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Aggregation(object):
    """
    Attributes:
     - name
     - inputColumn
     - operation
     - constructorJson
     - bucketColumns
     - windows
     - documentation
    """


    def __init__(self, name=None, inputColumn=None, operation=None, constructorJson=None, bucketColumns=None, windows=None, documentation=None,):
        self.name = name
        self.inputColumn = inputColumn
        self.operation = operation
        self.constructorJson = constructorJson
        self.bucketColumns = bucketColumns
        self.windows = windows
        self.documentation = documentation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.inputColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.operation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.constructorJson = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.bucketColumns = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.bucketColumns.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.windows = []
                    (_etype39, _size36) = iprot.readListBegin()
                    for _i40 in range(_size36):
                        _elem41 = Window()
                        _elem41.read(iprot)
                        self.windows.append(_elem41)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.documentation = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Aggregation')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.inputColumn is not None:
            oprot.writeFieldBegin('inputColumn', TType.STRING, 2)
            oprot.writeString(self.inputColumn.encode('utf-8') if sys.version_info[0] == 2 else self.inputColumn)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.I32, 3)
            oprot.writeI32(self.operation)
            oprot.writeFieldEnd()
        if self.constructorJson is not None:
            oprot.writeFieldBegin('constructorJson', TType.STRING, 4)
            oprot.writeString(self.constructorJson.encode('utf-8') if sys.version_info[0] == 2 else self.constructorJson)
            oprot.writeFieldEnd()
        if self.bucketColumns is not None:
            oprot.writeFieldBegin('bucketColumns', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.bucketColumns))
            for iter42 in self.bucketColumns:
                oprot.writeString(iter42.encode('utf-8') if sys.version_info[0] == 2 else iter42)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.windows is not None:
            oprot.writeFieldBegin('windows', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.windows))
            for iter43 in self.windows:
                iter43.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.documentation is not None:
            oprot.writeFieldBegin('documentation', TType.STRING, 7)
            oprot.writeString(self.documentation.encode('utf-8') if sys.version_info[0] == 2 else self.documentation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupBy(object):
    """
    Attributes:
     - name
     - sources
     - keyColumns
     - aggregations
     - metadata
    """


    def __init__(self, name=None, sources=None, keyColumns=None, aggregations=None, metadata=None,):
        self.name = name
        self.sources = sources
        self.keyColumns = keyColumns
        self.aggregations = aggregations
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sources = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = Source()
                        _elem49.read(iprot)
                        self.sources.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.keyColumns = []
                    (_etype53, _size50) = iprot.readListBegin()
                    for _i54 in range(_size50):
                        _elem55 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyColumns.append(_elem55)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aggregations = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = Aggregation()
                        _elem61.read(iprot)
                        self.aggregations.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.metadata = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupBy')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.sources is not None:
            oprot.writeFieldBegin('sources', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.sources))
            for iter62 in self.sources:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keyColumns is not None:
            oprot.writeFieldBegin('keyColumns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.keyColumns))
            for iter63 in self.keyColumns:
                oprot.writeString(iter63.encode('utf-8') if sys.version_info[0] == 2 else iter63)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregations is not None:
            oprot.writeFieldBegin('aggregations', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.aggregations))
            for iter64 in self.aggregations:
                iter64.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRING, 5)
            oprot.writeString(self.metadata.encode('utf-8') if sys.version_info[0] == 2 else self.metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggregationSelector(object):
    """
    Attributes:
     - name
     - windows
    """


    def __init__(self, name=None, windows=None,):
        self.name = name
        self.windows = windows

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.windows = []
                    (_etype68, _size65) = iprot.readListBegin()
                    for _i69 in range(_size65):
                        _elem70 = Window()
                        _elem70.read(iprot)
                        self.windows.append(_elem70)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggregationSelector')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.windows is not None:
            oprot.writeFieldBegin('windows', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.windows))
            for iter71 in self.windows:
                iter71.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinPart(object):
    """
    Attributes:
     - groupBy
     - keyMapping
     - selectors
     - prefix
    """


    def __init__(self, groupBy=None, keyMapping=None, selectors=None, prefix=None,):
        self.groupBy = groupBy
        self.keyMapping = keyMapping
        self.selectors = selectors
        self.prefix = prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.groupBy = GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.keyMapping = {}
                    (_ktype73, _vtype74, _size72) = iprot.readMapBegin()
                    for _i76 in range(_size72):
                        _key77 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val78 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyMapping[_key77] = _val78
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.selectors = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = AggregationSelector()
                        _elem84.read(iprot)
                        self.selectors.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.prefix = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinPart')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.keyMapping is not None:
            oprot.writeFieldBegin('keyMapping', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyMapping))
            for kiter85, viter86 in self.keyMapping.items():
                oprot.writeString(kiter85.encode('utf-8') if sys.version_info[0] == 2 else kiter85)
                oprot.writeString(viter86.encode('utf-8') if sys.version_info[0] == 2 else viter86)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.selectors is not None:
            oprot.writeFieldBegin('selectors', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.selectors))
            for iter87 in self.selectors:
                iter87.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.prefix is not None:
            oprot.writeFieldBegin('prefix', TType.STRING, 4)
            oprot.writeString(self.prefix.encode('utf-8') if sys.version_info[0] == 2 else self.prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LeftOuterJoin(object):
    """
    Attributes:
     - name
     - left
     - rightParts
     - metadata
    """


    def __init__(self, name=None, left=None, rightParts=None, metadata=None,):
        self.name = name
        self.left = left
        self.rightParts = rightParts
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.left = Source()
                    self.left.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.rightParts = []
                    (_etype91, _size88) = iprot.readListBegin()
                    for _i92 in range(_size88):
                        _elem93 = JoinPart()
                        _elem93.read(iprot)
                        self.rightParts.append(_elem93)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.metadata = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LeftOuterJoin')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.STRUCT, 2)
            self.left.write(oprot)
            oprot.writeFieldEnd()
        if self.rightParts is not None:
            oprot.writeFieldBegin('rightParts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.rightParts))
            for iter94 in self.rightParts:
                iter94.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRING, 4)
            oprot.writeString(self.metadata.encode('utf-8') if sys.version_info[0] == 2 else self.metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Query)
Query.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'select', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'where', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startPartition', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'endPartition', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'timeColumn', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'partitionColumn', 'UTF8', "ds", ),  # 6
    (7, TType.STRING, 'partitionFormat', 'UTF8', "yyyy-MM-dd", ),  # 7
    (8, TType.LIST, 'setups', (TType.STRING, 'UTF8', False), [
    ], ),  # 8
    (9, TType.STRING, 'ingestionTimeColumn', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'reversalColumn', 'UTF8', None, ),  # 10
    (11, TType.STRING, 'additionalPartitions', 'UTF8', None, ),  # 11
    (12, TType.I32, 'partitionLag', None, 0, ),  # 12
)
all_structs.append(StagingQuery)
StagingQuery.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startDate', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'dependencies', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'querySetupCommands', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(EventSource)
EventSource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'topic', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'query', [Query, None], None, ),  # 3
    (4, TType.I32, 'partitionStrategy', None, 0, ),  # 4
)
all_structs.append(EntitySource)
EntitySource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snapshotTable', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mutationTable', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mutationTopic', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'query', [Query, None], None, ),  # 4
)
all_structs.append(Source)
Source.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'events', [EventSource, None], None, ),  # 1
    (2, TType.STRUCT, 'entities', [EntitySource, None], None, ),  # 2
)
all_structs.append(Window)
Window.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'length', None, None, ),  # 1
    (2, TType.I32, 'timeUnit', None, None, ),  # 2
)
all_structs.append(Aggregation)
Aggregation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'inputColumn', 'UTF8', None, ),  # 2
    (3, TType.I32, 'operation', None, None, ),  # 3
    (4, TType.STRING, 'constructorJson', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'bucketColumns', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.LIST, 'windows', (TType.STRUCT, [Window, None], False), None, ),  # 6
    (7, TType.STRING, 'documentation', 'UTF8', None, ),  # 7
)
all_structs.append(GroupBy)
GroupBy.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'sources', (TType.STRUCT, [Source, None], False), None, ),  # 2
    (3, TType.LIST, 'keyColumns', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'aggregations', (TType.STRUCT, [Aggregation, None], False), None, ),  # 4
    (5, TType.STRING, 'metadata', 'UTF8', None, ),  # 5
)
all_structs.append(AggregationSelector)
AggregationSelector.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'windows', (TType.STRUCT, [Window, None], False), None, ),  # 2
)
all_structs.append(JoinPart)
JoinPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'groupBy', [GroupBy, None], None, ),  # 1
    (2, TType.MAP, 'keyMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'selectors', (TType.STRUCT, [AggregationSelector, None], False), None, ),  # 3
    (4, TType.STRING, 'prefix', 'UTF8', None, ),  # 4
)
all_structs.append(LeftOuterJoin)
LeftOuterJoin.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'left', [Source, None], None, ),  # 2
    (3, TType.LIST, 'rightParts', (TType.STRUCT, [JoinPart, None], False), None, ),  # 3
    (4, TType.STRING, 'metadata', 'UTF8', None, ),  # 4
)
fix_spec(all_structs)
del all_structs
