module RandArray {
  use Random;
  use SegmentedArray;

  proc fillInt(a:[] ?t, const aMin: t, const aMax: t) where isIntegral(t) {
    coforall loc in Locales {
      on loc {
        ref myA = a.localSlice[a.localSubdomain()];
        fillRandom(myA);
        [ai in myA] if (ai < 0) { ai = -ai; }
        if (aMax > aMin) {
          const modulus:t = aMax - aMin;
          myA = (myA % modulus) + aMin;
        }
      }
    }
  }

  proc fillReal(a:[] real, const aMin=0, const aMax=1) {
    coforall loc in Locales {
      on loc {
        ref myA = a.localSlice[a.localSubdomain()];
        fillRandom(myA);
        const scale = aMax - aMin;
        myA = scale*myA + aMin;
      }
    }
  }

  proc fillBool(a:[] bool) {
    coforall loc in Locales {
      on loc {
        ref myA = a.localSlice[a.localSubdomain()];
        fillRandom(myA);
      }
    }
  }

  enum charSet {
    Uppercase,
    Lowercase,
    Numeric,
    Printable,
    Binary
  }

  var charBounds: map(charSet, 2*uint(8));
  charBounds[charSet.Uppercase] = (65:uint(8), 91:uint(8));
  charBounds[charSet.Lowercase] = (97:uint(8), 123:uint(8));
  charBounds[charSet.Numeric] = (48:uint(8), 58:uint(8));
  charBounds[charSet.Printable] = (32:uint(8), 127:uint(8));
  charBounds[charSet.Binary] = (0:uint(8), 0:uint(8));
  
  proc newRandStrings(n: int, const minLen: int, const maxLen: int, characters:charSet = charSet.Uppercase) {
    var lengths = makeDistArray(n, int);
    fillInt(lengths, minLen+1, maxLen+1);
    const nBytes = + reduce lengths;
    var segs = (+ scan lengths) - lengths;
    var vals = makeDistArray(nBytes, uint(8));
    var (lb, ub) = charBounds[characters];
    fillInt(vals, lb, ub);
  }
}