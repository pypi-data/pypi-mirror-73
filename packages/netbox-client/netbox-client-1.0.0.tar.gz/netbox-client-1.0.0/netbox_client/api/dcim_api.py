# coding: utf-8

"""
    NetBox API

    API to access NetBox  # noqa: E501

    OpenAPI spec version: 2.8
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from netbox_client.api_client import ApiClient


class DcimApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def dcim_cables_create(self, data, **kwargs):  # noqa: E501
        """dcim_cables_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableCable data: (required)
        :return: Cable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_cables_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_cables_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_cables_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_cables_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableCable data: (required)
        :return: Cable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_cables_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_cables_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/cables/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Cable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_cables_delete(self, id, **kwargs):  # noqa: E501
        """dcim_cables_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this cable. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_cables_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_cables_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_cables_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_cables_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this cable. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_cables_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_cables_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/cables/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_cables_list(self, **kwargs):  # noqa: E501
        """dcim_cables_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str label: 
        :param str length: 
        :param str length_unit: 
        :param str q: 
        :param str type: 
        :param str status: 
        :param str color: 
        :param str device_id: 
        :param str device: 
        :param str rack_id: 
        :param str rack: 
        :param str site_id: 
        :param str site: 
        :param str tenant_id: 
        :param str tenant: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str label__n: 
        :param str label__ic: 
        :param str label__nic: 
        :param str label__iew: 
        :param str label__niew: 
        :param str label__isw: 
        :param str label__nisw: 
        :param str label__ie: 
        :param str label__nie: 
        :param str length__n: 
        :param str length__lte: 
        :param str length__lt: 
        :param str length__gte: 
        :param str length__gt: 
        :param str length_unit__n: 
        :param str type__n: 
        :param str status__n: 
        :param str color__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_cables_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_cables_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_cables_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_cables_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str label: 
        :param str length: 
        :param str length_unit: 
        :param str q: 
        :param str type: 
        :param str status: 
        :param str color: 
        :param str device_id: 
        :param str device: 
        :param str rack_id: 
        :param str rack: 
        :param str site_id: 
        :param str site: 
        :param str tenant_id: 
        :param str tenant: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str label__n: 
        :param str label__ic: 
        :param str label__nic: 
        :param str label__iew: 
        :param str label__niew: 
        :param str label__isw: 
        :param str label__nisw: 
        :param str label__ie: 
        :param str label__nie: 
        :param str length__n: 
        :param str length__lte: 
        :param str length__lt: 
        :param str length__gte: 
        :param str length__gt: 
        :param str length_unit__n: 
        :param str type__n: 
        :param str status__n: 
        :param str color__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'label', 'length', 'length_unit', 'q', 'type', 'status', 'color', 'device_id', 'device', 'rack_id', 'rack', 'site_id', 'site', 'tenant_id', 'tenant', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'label__n', 'label__ic', 'label__nic', 'label__iew', 'label__niew', 'label__isw', 'label__nisw', 'label__ie', 'label__nie', 'length__n', 'length__lte', 'length__lt', 'length__gte', 'length__gt', 'length_unit__n', 'type__n', 'status__n', 'color__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_cables_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'label' in params:
            query_params.append(('label', params['label']))  # noqa: E501
        if 'length' in params:
            query_params.append(('length', params['length']))  # noqa: E501
        if 'length_unit' in params:
            query_params.append(('length_unit', params['length_unit']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'color' in params:
            query_params.append(('color', params['color']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'rack_id' in params:
            query_params.append(('rack_id', params['rack_id']))  # noqa: E501
        if 'rack' in params:
            query_params.append(('rack', params['rack']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'tenant_id' in params:
            query_params.append(('tenant_id', params['tenant_id']))  # noqa: E501
        if 'tenant' in params:
            query_params.append(('tenant', params['tenant']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'label__n' in params:
            query_params.append(('label__n', params['label__n']))  # noqa: E501
        if 'label__ic' in params:
            query_params.append(('label__ic', params['label__ic']))  # noqa: E501
        if 'label__nic' in params:
            query_params.append(('label__nic', params['label__nic']))  # noqa: E501
        if 'label__iew' in params:
            query_params.append(('label__iew', params['label__iew']))  # noqa: E501
        if 'label__niew' in params:
            query_params.append(('label__niew', params['label__niew']))  # noqa: E501
        if 'label__isw' in params:
            query_params.append(('label__isw', params['label__isw']))  # noqa: E501
        if 'label__nisw' in params:
            query_params.append(('label__nisw', params['label__nisw']))  # noqa: E501
        if 'label__ie' in params:
            query_params.append(('label__ie', params['label__ie']))  # noqa: E501
        if 'label__nie' in params:
            query_params.append(('label__nie', params['label__nie']))  # noqa: E501
        if 'length__n' in params:
            query_params.append(('length__n', params['length__n']))  # noqa: E501
        if 'length__lte' in params:
            query_params.append(('length__lte', params['length__lte']))  # noqa: E501
        if 'length__lt' in params:
            query_params.append(('length__lt', params['length__lt']))  # noqa: E501
        if 'length__gte' in params:
            query_params.append(('length__gte', params['length__gte']))  # noqa: E501
        if 'length__gt' in params:
            query_params.append(('length__gt', params['length__gt']))  # noqa: E501
        if 'length_unit__n' in params:
            query_params.append(('length_unit__n', params['length_unit__n']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'status__n' in params:
            query_params.append(('status__n', params['status__n']))  # noqa: E501
        if 'color__n' in params:
            query_params.append(('color__n', params['color__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/cables/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_cables_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_cables_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this cable. (required)
        :param WritableCable data: (required)
        :return: Cable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_cables_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_cables_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_cables_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_cables_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this cable. (required)
        :param WritableCable data: (required)
        :return: Cable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_cables_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_cables_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_cables_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/cables/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Cable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_cables_read(self, id, **kwargs):  # noqa: E501
        """dcim_cables_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this cable. (required)
        :return: Cable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_cables_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_cables_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_cables_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_cables_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this cable. (required)
        :return: Cable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_cables_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_cables_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/cables/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Cable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_cables_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_cables_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this cable. (required)
        :param WritableCable data: (required)
        :return: Cable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_cables_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_cables_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_cables_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_cables_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_cables_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this cable. (required)
        :param WritableCable data: (required)
        :return: Cable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_cables_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_cables_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_cables_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/cables/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Cable',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_connected_device_list(self, peer_device, peer_interface, **kwargs):  # noqa: E501
        """dcim_connected_device_list  # noqa: E501

        This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_connected_device_list(peer_device, peer_interface, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str peer_device: The name of the peer device (required)
        :param str peer_interface: The name of the peer interface (required)
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_connected_device_list_with_http_info(peer_device, peer_interface, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_connected_device_list_with_http_info(peer_device, peer_interface, **kwargs)  # noqa: E501
            return data

    def dcim_connected_device_list_with_http_info(self, peer_device, peer_interface, **kwargs):  # noqa: E501
        """dcim_connected_device_list  # noqa: E501

        This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_connected_device_list_with_http_info(peer_device, peer_interface, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str peer_device: The name of the peer device (required)
        :param str peer_interface: The name of the peer interface (required)
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['peer_device', 'peer_interface']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_connected_device_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'peer_device' is set
        if ('peer_device' not in params or
                params['peer_device'] is None):
            raise ValueError("Missing the required parameter `peer_device` when calling `dcim_connected_device_list`")  # noqa: E501
        # verify the required parameter 'peer_interface' is set
        if ('peer_interface' not in params or
                params['peer_interface'] is None):
            raise ValueError("Missing the required parameter `peer_interface` when calling `dcim_connected_device_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'peer_device' in params:
            query_params.append(('peer_device', params['peer_device']))  # noqa: E501
        if 'peer_interface' in params:
            query_params.append(('peer_interface', params['peer_interface']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/connected-device/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Device',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_connections_list(self, **kwargs):  # noqa: E501
        """dcim_console_connections_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_connections_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 
        :param str connection_status: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str connection_status__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_connections_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_connections_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_console_connections_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_console_connections_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_connections_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 
        :param str connection_status: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str connection_status__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'connection_status', 'site', 'device_id', 'device', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'connection_status__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_connections_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'connection_status' in params:
            query_params.append(('connection_status', params['connection_status']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'connection_status__n' in params:
            query_params.append(('connection_status__n', params['connection_status__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-connections/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_port_templates_create(self, data, **kwargs):  # noqa: E501
        """dcim_console_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableConsolePortTemplate data: (required)
        :return: ConsolePortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_console_port_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_console_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableConsolePortTemplate data: (required)
        :return: ConsolePortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_port_templates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_port_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-port-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_port_templates_delete(self, id, **kwargs):  # noqa: E501
        """dcim_console_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_port_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_port_templates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_port_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-port-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_port_templates_list(self, **kwargs):  # noqa: E501
        """dcim_console_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_port_templates_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_port_templates_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_console_port_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_console_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'q', 'devicetype_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'devicetype_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_port_templates_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'devicetype_id' in params:
            query_params.append(('devicetype_id', params['devicetype_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'devicetype_id__n' in params:
            query_params.append(('devicetype_id__n', params['devicetype_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-port-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_port_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port template. (required)
        :param WritableConsolePortTemplate data: (required)
        :return: ConsolePortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_console_port_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port template. (required)
        :param WritableConsolePortTemplate data: (required)
        :return: ConsolePortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_port_templates_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_port_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_port_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-port-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_port_templates_read(self, id, **kwargs):  # noqa: E501
        """dcim_console_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port template. (required)
        :return: ConsolePortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_port_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port template. (required)
        :return: ConsolePortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_port_templates_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_port_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-port-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_port_templates_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port template. (required)
        :param WritableConsolePortTemplate data: (required)
        :return: ConsolePortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_console_port_templates_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_port_templates_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port template. (required)
        :param WritableConsolePortTemplate data: (required)
        :return: ConsolePortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_port_templates_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_port_templates_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_port_templates_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-port-templates/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_ports_create(self, data, **kwargs):  # noqa: E501
        """dcim_console_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableConsolePort data: (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_ports_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_ports_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_console_ports_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_console_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableConsolePort data: (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_ports_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_ports_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-ports/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_ports_delete(self, id, **kwargs):  # noqa: E501
        """dcim_console_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_ports_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_ports_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_ports_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-ports/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_ports_list(self, **kwargs):  # noqa: E501
        """dcim_console_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str description: 
        :param str connection_status: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str type: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str connection_status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str type__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_ports_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_ports_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_console_ports_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_console_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str description: 
        :param str connection_status: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str type: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str connection_status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str type__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'description', 'connection_status', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'type', 'cabled', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'connection_status__n', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'device_id__n', 'device__n', 'tag__n', 'type__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_ports_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'connection_status' in params:
            query_params.append(('connection_status', params['connection_status']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'cabled' in params:
            query_params.append(('cabled', params['cabled']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'connection_status__n' in params:
            query_params.append(('connection_status__n', params['connection_status__n']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'device_id__n' in params:
            query_params.append(('device_id__n', params['device_id__n']))  # noqa: E501
        if 'device__n' in params:
            query_params.append(('device__n', params['device__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-ports/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_ports_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :param WritableConsolePort data: (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_console_ports_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :param WritableConsolePort data: (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_ports_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_ports_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_ports_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-ports/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_ports_read(self, id, **kwargs):  # noqa: E501
        """dcim_console_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_ports_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_ports_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_ports_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_ports_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_ports_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-ports/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_ports_trace(self, id, **kwargs):  # noqa: E501
        """dcim_console_ports_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_trace(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_ports_trace_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_ports_trace_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_ports_trace_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_ports_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_trace_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_ports_trace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_ports_trace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-ports/{id}/trace/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_ports_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :param WritableConsolePort data: (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_console_ports_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_ports_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console port. (required)
        :param WritableConsolePort data: (required)
        :return: ConsolePort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_ports_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_ports_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_ports_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-ports/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsolePort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_port_templates_create(self, data, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableConsoleServerPortTemplate data: (required)
        :return: ConsoleServerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_port_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableConsoleServerPortTemplate data: (required)
        :return: ConsoleServerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_port_templates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_server_port_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-port-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_port_templates_delete(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_port_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_port_templates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_port_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-port-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_port_templates_list(self, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_port_templates_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_port_templates_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_console_server_port_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'q', 'devicetype_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'devicetype_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_port_templates_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'devicetype_id' in params:
            query_params.append(('devicetype_id', params['devicetype_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'devicetype_id__n' in params:
            query_params.append(('devicetype_id__n', params['devicetype_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-port-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_port_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port template. (required)
        :param WritableConsoleServerPortTemplate data: (required)
        :return: ConsoleServerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_port_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port template. (required)
        :param WritableConsoleServerPortTemplate data: (required)
        :return: ConsoleServerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_port_templates_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_port_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_server_port_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-port-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_port_templates_read(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port template. (required)
        :return: ConsoleServerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_port_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port template. (required)
        :return: ConsoleServerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_port_templates_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_port_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-port-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_port_templates_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port template. (required)
        :param WritableConsoleServerPortTemplate data: (required)
        :return: ConsoleServerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_port_templates_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_server_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_port_templates_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port template. (required)
        :param WritableConsoleServerPortTemplate data: (required)
        :return: ConsoleServerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_port_templates_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_port_templates_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_server_port_templates_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-port-templates/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_ports_create(self, data, **kwargs):  # noqa: E501
        """dcim_console_server_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableConsoleServerPort data: (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_ports_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_ports_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_ports_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_console_server_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableConsoleServerPort data: (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_ports_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_server_ports_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-ports/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_ports_delete(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_ports_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_ports_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_ports_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-ports/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_ports_list(self, **kwargs):  # noqa: E501
        """dcim_console_server_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str description: 
        :param str connection_status: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str type: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str connection_status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str type__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_ports_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_ports_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_console_server_ports_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_console_server_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str description: 
        :param str connection_status: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str type: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str connection_status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str type__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'description', 'connection_status', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'type', 'cabled', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'connection_status__n', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'device_id__n', 'device__n', 'tag__n', 'type__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_ports_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'connection_status' in params:
            query_params.append(('connection_status', params['connection_status']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'cabled' in params:
            query_params.append(('cabled', params['cabled']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'connection_status__n' in params:
            query_params.append(('connection_status__n', params['connection_status__n']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'device_id__n' in params:
            query_params.append(('device_id__n', params['device_id__n']))  # noqa: E501
        if 'device__n' in params:
            query_params.append(('device__n', params['device__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-ports/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_ports_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_server_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :param WritableConsoleServerPort data: (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_ports_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_server_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :param WritableConsoleServerPort data: (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_ports_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_ports_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_server_ports_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-ports/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_ports_read(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_ports_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_ports_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_ports_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_ports_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_ports_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-ports/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_ports_trace(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_ports_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_trace(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_ports_trace_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_ports_trace_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_ports_trace_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_console_server_ports_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_trace_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_ports_trace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_ports_trace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-ports/{id}/trace/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_console_server_ports_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_server_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :param WritableConsoleServerPort data: (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_console_server_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_console_server_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_console_server_ports_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_console_server_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_console_server_ports_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this console server port. (required)
        :param WritableConsoleServerPort data: (required)
        :return: ConsoleServerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_console_server_ports_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_console_server_ports_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_console_server_ports_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/console-server-ports/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConsoleServerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bay_templates_create(self, data, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceBayTemplate data: (required)
        :return: DeviceBayTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bay_templates_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bay_templates_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_device_bay_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceBayTemplate data: (required)
        :return: DeviceBayTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bay_templates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_bay_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bay-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceBayTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bay_templates_delete(self, id, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bay_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bay_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_device_bay_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bay_templates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_bay_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bay-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bay_templates_list(self, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bay_templates_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bay_templates_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_device_bay_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'q', 'devicetype_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'devicetype_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bay_templates_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'devicetype_id' in params:
            query_params.append(('devicetype_id', params['devicetype_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'devicetype_id__n' in params:
            query_params.append(('devicetype_id__n', params['devicetype_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bay-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bay_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay template. (required)
        :param WritableDeviceBayTemplate data: (required)
        :return: DeviceBayTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bay_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bay_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_device_bay_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay template. (required)
        :param WritableDeviceBayTemplate data: (required)
        :return: DeviceBayTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bay_templates_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_bay_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_bay_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bay-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceBayTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bay_templates_read(self, id, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay template. (required)
        :return: DeviceBayTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bay_templates_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bay_templates_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_device_bay_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay template. (required)
        :return: DeviceBayTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bay_templates_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_bay_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bay-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceBayTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bay_templates_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay template. (required)
        :param WritableDeviceBayTemplate data: (required)
        :return: DeviceBayTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bay_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bay_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_device_bay_templates_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_bay_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bay_templates_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay template. (required)
        :param WritableDeviceBayTemplate data: (required)
        :return: DeviceBayTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bay_templates_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_bay_templates_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_bay_templates_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bay-templates/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceBayTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bays_create(self, data, **kwargs):  # noqa: E501
        """dcim_device_bays_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceBay data: (required)
        :return: DeviceBay
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bays_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bays_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_device_bays_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_device_bays_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceBay data: (required)
        :return: DeviceBay
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bays_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_bays_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bays/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceBay',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bays_delete(self, id, **kwargs):  # noqa: E501
        """dcim_device_bays_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bays_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bays_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_device_bays_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_device_bays_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bays_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_bays_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bays/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bays_list(self, **kwargs):  # noqa: E501
        """dcim_device_bays_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bays_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bays_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_device_bays_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_device_bays_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'description', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'device_id__n', 'device__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bays_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'device_id__n' in params:
            query_params.append(('device_id__n', params['device_id__n']))  # noqa: E501
        if 'device__n' in params:
            query_params.append(('device__n', params['device__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bays/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bays_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_bays_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay. (required)
        :param WritableDeviceBay data: (required)
        :return: DeviceBay
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bays_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bays_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_device_bays_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_bays_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay. (required)
        :param WritableDeviceBay data: (required)
        :return: DeviceBay
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bays_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_bays_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_bays_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bays/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceBay',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bays_read(self, id, **kwargs):  # noqa: E501
        """dcim_device_bays_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay. (required)
        :return: DeviceBay
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bays_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bays_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_device_bays_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_device_bays_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay. (required)
        :return: DeviceBay
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bays_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_bays_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bays/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceBay',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_bays_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_bays_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay. (required)
        :param WritableDeviceBay data: (required)
        :return: DeviceBay
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_bays_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_bays_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_device_bays_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_bays_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_bays_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device bay. (required)
        :param WritableDeviceBay data: (required)
        :return: DeviceBay
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_bays_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_bays_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_bays_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-bays/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceBay',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_roles_create(self, data, **kwargs):  # noqa: E501
        """dcim_device_roles_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceRole data: (required)
        :return: DeviceRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_roles_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_roles_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_device_roles_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_device_roles_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceRole data: (required)
        :return: DeviceRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_roles_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_roles_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-roles/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_roles_delete(self, id, **kwargs):  # noqa: E501
        """dcim_device_roles_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device role. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_roles_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_roles_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_device_roles_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_device_roles_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device role. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_roles_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_roles_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-roles/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_roles_list(self, **kwargs):  # noqa: E501
        """dcim_device_roles_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str color: 
        :param str vm_role: 
        :param str q: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str color__n: 
        :param str color__ic: 
        :param str color__nic: 
        :param str color__iew: 
        :param str color__niew: 
        :param str color__isw: 
        :param str color__nisw: 
        :param str color__ie: 
        :param str color__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_roles_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_roles_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_device_roles_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_device_roles_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str color: 
        :param str vm_role: 
        :param str q: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str color__n: 
        :param str color__ic: 
        :param str color__nic: 
        :param str color__iew: 
        :param str color__niew: 
        :param str color__isw: 
        :param str color__nisw: 
        :param str color__ie: 
        :param str color__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'color', 'vm_role', 'q', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'color__n', 'color__ic', 'color__nic', 'color__iew', 'color__niew', 'color__isw', 'color__nisw', 'color__ie', 'color__nie', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_roles_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'color' in params:
            query_params.append(('color', params['color']))  # noqa: E501
        if 'vm_role' in params:
            query_params.append(('vm_role', params['vm_role']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'color__n' in params:
            query_params.append(('color__n', params['color__n']))  # noqa: E501
        if 'color__ic' in params:
            query_params.append(('color__ic', params['color__ic']))  # noqa: E501
        if 'color__nic' in params:
            query_params.append(('color__nic', params['color__nic']))  # noqa: E501
        if 'color__iew' in params:
            query_params.append(('color__iew', params['color__iew']))  # noqa: E501
        if 'color__niew' in params:
            query_params.append(('color__niew', params['color__niew']))  # noqa: E501
        if 'color__isw' in params:
            query_params.append(('color__isw', params['color__isw']))  # noqa: E501
        if 'color__nisw' in params:
            query_params.append(('color__nisw', params['color__nisw']))  # noqa: E501
        if 'color__ie' in params:
            query_params.append(('color__ie', params['color__ie']))  # noqa: E501
        if 'color__nie' in params:
            query_params.append(('color__nie', params['color__nie']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-roles/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_roles_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_roles_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device role. (required)
        :param DeviceRole data: (required)
        :return: DeviceRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_roles_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_roles_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_device_roles_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_roles_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device role. (required)
        :param DeviceRole data: (required)
        :return: DeviceRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_roles_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_roles_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_roles_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-roles/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_roles_read(self, id, **kwargs):  # noqa: E501
        """dcim_device_roles_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device role. (required)
        :return: DeviceRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_roles_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_roles_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_device_roles_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_device_roles_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device role. (required)
        :return: DeviceRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_roles_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_roles_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-roles/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_roles_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_roles_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device role. (required)
        :param DeviceRole data: (required)
        :return: DeviceRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_roles_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_roles_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_device_roles_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_roles_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_roles_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device role. (required)
        :param DeviceRole data: (required)
        :return: DeviceRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_roles_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_roles_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_roles_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-roles/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_types_create(self, data, **kwargs):  # noqa: E501
        """dcim_device_types_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceType data: (required)
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_types_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_types_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_device_types_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_device_types_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceType data: (required)
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_types_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_types_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-types/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_types_delete(self, id, **kwargs):  # noqa: E501
        """dcim_device_types_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_types_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_types_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_device_types_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_device_types_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_types_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_types_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-types/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_types_list(self, **kwargs):  # noqa: E501
        """dcim_device_types_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str model: 
        :param str slug: 
        :param str part_number: 
        :param str u_height: 
        :param str is_full_depth: 
        :param str subdevice_role: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str manufacturer_id: 
        :param str manufacturer: 
        :param str console_ports: 
        :param str console_server_ports: 
        :param str power_ports: 
        :param str power_outlets: 
        :param str interfaces: 
        :param str pass_through_ports: 
        :param str device_bays: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str model__n: 
        :param str model__ic: 
        :param str model__nic: 
        :param str model__iew: 
        :param str model__niew: 
        :param str model__isw: 
        :param str model__nisw: 
        :param str model__ie: 
        :param str model__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str part_number__n: 
        :param str part_number__ic: 
        :param str part_number__nic: 
        :param str part_number__iew: 
        :param str part_number__niew: 
        :param str part_number__isw: 
        :param str part_number__nisw: 
        :param str part_number__ie: 
        :param str part_number__nie: 
        :param str u_height__n: 
        :param str u_height__lte: 
        :param str u_height__lt: 
        :param str u_height__gte: 
        :param str u_height__gt: 
        :param str subdevice_role__n: 
        :param str manufacturer_id__n: 
        :param str manufacturer__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_types_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_types_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_device_types_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_device_types_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str model: 
        :param str slug: 
        :param str part_number: 
        :param str u_height: 
        :param str is_full_depth: 
        :param str subdevice_role: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str manufacturer_id: 
        :param str manufacturer: 
        :param str console_ports: 
        :param str console_server_ports: 
        :param str power_ports: 
        :param str power_outlets: 
        :param str interfaces: 
        :param str pass_through_ports: 
        :param str device_bays: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str model__n: 
        :param str model__ic: 
        :param str model__nic: 
        :param str model__iew: 
        :param str model__niew: 
        :param str model__isw: 
        :param str model__nisw: 
        :param str model__ie: 
        :param str model__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str part_number__n: 
        :param str part_number__ic: 
        :param str part_number__nic: 
        :param str part_number__iew: 
        :param str part_number__niew: 
        :param str part_number__isw: 
        :param str part_number__nisw: 
        :param str part_number__ie: 
        :param str part_number__nie: 
        :param str u_height__n: 
        :param str u_height__lte: 
        :param str u_height__lt: 
        :param str u_height__gte: 
        :param str u_height__gt: 
        :param str subdevice_role__n: 
        :param str manufacturer_id__n: 
        :param str manufacturer__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'model', 'slug', 'part_number', 'u_height', 'is_full_depth', 'subdevice_role', 'created', 'created__gte', 'created__lte', 'last_updated', 'last_updated__gte', 'last_updated__lte', 'q', 'manufacturer_id', 'manufacturer', 'console_ports', 'console_server_ports', 'power_ports', 'power_outlets', 'interfaces', 'pass_through_ports', 'device_bays', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'model__n', 'model__ic', 'model__nic', 'model__iew', 'model__niew', 'model__isw', 'model__nisw', 'model__ie', 'model__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'part_number__n', 'part_number__ic', 'part_number__nic', 'part_number__iew', 'part_number__niew', 'part_number__isw', 'part_number__nisw', 'part_number__ie', 'part_number__nie', 'u_height__n', 'u_height__lte', 'u_height__lt', 'u_height__gte', 'u_height__gt', 'subdevice_role__n', 'manufacturer_id__n', 'manufacturer__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_types_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'model' in params:
            query_params.append(('model', params['model']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'part_number' in params:
            query_params.append(('part_number', params['part_number']))  # noqa: E501
        if 'u_height' in params:
            query_params.append(('u_height', params['u_height']))  # noqa: E501
        if 'is_full_depth' in params:
            query_params.append(('is_full_depth', params['is_full_depth']))  # noqa: E501
        if 'subdevice_role' in params:
            query_params.append(('subdevice_role', params['subdevice_role']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('created__gte', params['created__gte']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('created__lte', params['created__lte']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('last_updated', params['last_updated']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'manufacturer_id' in params:
            query_params.append(('manufacturer_id', params['manufacturer_id']))  # noqa: E501
        if 'manufacturer' in params:
            query_params.append(('manufacturer', params['manufacturer']))  # noqa: E501
        if 'console_ports' in params:
            query_params.append(('console_ports', params['console_ports']))  # noqa: E501
        if 'console_server_ports' in params:
            query_params.append(('console_server_ports', params['console_server_ports']))  # noqa: E501
        if 'power_ports' in params:
            query_params.append(('power_ports', params['power_ports']))  # noqa: E501
        if 'power_outlets' in params:
            query_params.append(('power_outlets', params['power_outlets']))  # noqa: E501
        if 'interfaces' in params:
            query_params.append(('interfaces', params['interfaces']))  # noqa: E501
        if 'pass_through_ports' in params:
            query_params.append(('pass_through_ports', params['pass_through_ports']))  # noqa: E501
        if 'device_bays' in params:
            query_params.append(('device_bays', params['device_bays']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'model__n' in params:
            query_params.append(('model__n', params['model__n']))  # noqa: E501
        if 'model__ic' in params:
            query_params.append(('model__ic', params['model__ic']))  # noqa: E501
        if 'model__nic' in params:
            query_params.append(('model__nic', params['model__nic']))  # noqa: E501
        if 'model__iew' in params:
            query_params.append(('model__iew', params['model__iew']))  # noqa: E501
        if 'model__niew' in params:
            query_params.append(('model__niew', params['model__niew']))  # noqa: E501
        if 'model__isw' in params:
            query_params.append(('model__isw', params['model__isw']))  # noqa: E501
        if 'model__nisw' in params:
            query_params.append(('model__nisw', params['model__nisw']))  # noqa: E501
        if 'model__ie' in params:
            query_params.append(('model__ie', params['model__ie']))  # noqa: E501
        if 'model__nie' in params:
            query_params.append(('model__nie', params['model__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'part_number__n' in params:
            query_params.append(('part_number__n', params['part_number__n']))  # noqa: E501
        if 'part_number__ic' in params:
            query_params.append(('part_number__ic', params['part_number__ic']))  # noqa: E501
        if 'part_number__nic' in params:
            query_params.append(('part_number__nic', params['part_number__nic']))  # noqa: E501
        if 'part_number__iew' in params:
            query_params.append(('part_number__iew', params['part_number__iew']))  # noqa: E501
        if 'part_number__niew' in params:
            query_params.append(('part_number__niew', params['part_number__niew']))  # noqa: E501
        if 'part_number__isw' in params:
            query_params.append(('part_number__isw', params['part_number__isw']))  # noqa: E501
        if 'part_number__nisw' in params:
            query_params.append(('part_number__nisw', params['part_number__nisw']))  # noqa: E501
        if 'part_number__ie' in params:
            query_params.append(('part_number__ie', params['part_number__ie']))  # noqa: E501
        if 'part_number__nie' in params:
            query_params.append(('part_number__nie', params['part_number__nie']))  # noqa: E501
        if 'u_height__n' in params:
            query_params.append(('u_height__n', params['u_height__n']))  # noqa: E501
        if 'u_height__lte' in params:
            query_params.append(('u_height__lte', params['u_height__lte']))  # noqa: E501
        if 'u_height__lt' in params:
            query_params.append(('u_height__lt', params['u_height__lt']))  # noqa: E501
        if 'u_height__gte' in params:
            query_params.append(('u_height__gte', params['u_height__gte']))  # noqa: E501
        if 'u_height__gt' in params:
            query_params.append(('u_height__gt', params['u_height__gt']))  # noqa: E501
        if 'subdevice_role__n' in params:
            query_params.append(('subdevice_role__n', params['subdevice_role__n']))  # noqa: E501
        if 'manufacturer_id__n' in params:
            query_params.append(('manufacturer_id__n', params['manufacturer_id__n']))  # noqa: E501
        if 'manufacturer__n' in params:
            query_params.append(('manufacturer__n', params['manufacturer__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-types/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_types_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_types_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device type. (required)
        :param WritableDeviceType data: (required)
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_types_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_types_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_device_types_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_types_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device type. (required)
        :param WritableDeviceType data: (required)
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_types_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_types_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_types_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-types/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_types_read(self, id, **kwargs):  # noqa: E501
        """dcim_device_types_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device type. (required)
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_types_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_types_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_device_types_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_device_types_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device type. (required)
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_types_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_types_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-types/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_device_types_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_types_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device type. (required)
        :param WritableDeviceType data: (required)
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_device_types_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_device_types_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_device_types_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_device_types_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_device_types_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device type. (required)
        :param WritableDeviceType data: (required)
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_device_types_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_device_types_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_device_types_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/device-types/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_devices_create(self, data, **kwargs):  # noqa: E501
        """dcim_devices_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceWithConfigContext data: (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_devices_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_devices_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_devices_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_devices_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceWithConfigContext data: (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_devices_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_devices_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/devices/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceWithConfigContext',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_devices_delete(self, id, **kwargs):  # noqa: E501
        """dcim_devices_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_devices_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_devices_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_devices_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_devices_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_devices_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_devices_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/devices/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_devices_graphs(self, id, **kwargs):  # noqa: E501
        """dcim_devices_graphs  # noqa: E501

        A convenience method for rendering graphs for a particular Device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_graphs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_devices_graphs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_devices_graphs_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_devices_graphs_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_devices_graphs  # noqa: E501

        A convenience method for rendering graphs for a particular Device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_graphs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_devices_graphs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_devices_graphs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/devices/{id}/graphs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceWithConfigContext',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_devices_list(self, **kwargs):  # noqa: E501
        """dcim_devices_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str asset_tag: 
        :param str face: 
        :param str position: 
        :param str vc_position: 
        :param str vc_priority: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str local_context_data: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str manufacturer_id: 
        :param str manufacturer: 
        :param str device_type_id: 
        :param str role_id: 
        :param str role: 
        :param str platform_id: 
        :param str platform: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str rack_group_id: 
        :param str rack_id: 
        :param str cluster_id: 
        :param str model: 
        :param str status: 
        :param str is_full_depth: 
        :param str mac_address: 
        :param str serial: 
        :param str has_primary_ip: 
        :param str virtual_chassis_id: 
        :param str virtual_chassis_member: 
        :param str console_ports: 
        :param str console_server_ports: 
        :param str power_ports: 
        :param str power_outlets: 
        :param str interfaces: 
        :param str pass_through_ports: 
        :param str device_bays: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str asset_tag__n: 
        :param str asset_tag__ic: 
        :param str asset_tag__nic: 
        :param str asset_tag__iew: 
        :param str asset_tag__niew: 
        :param str asset_tag__isw: 
        :param str asset_tag__nisw: 
        :param str asset_tag__ie: 
        :param str asset_tag__nie: 
        :param str face__n: 
        :param str position__n: 
        :param str position__lte: 
        :param str position__lt: 
        :param str position__gte: 
        :param str position__gt: 
        :param str vc_position__n: 
        :param str vc_position__lte: 
        :param str vc_position__lt: 
        :param str vc_position__gte: 
        :param str vc_position__gt: 
        :param str vc_priority__n: 
        :param str vc_priority__lte: 
        :param str vc_priority__lt: 
        :param str vc_priority__gte: 
        :param str vc_priority__gt: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str manufacturer_id__n: 
        :param str manufacturer__n: 
        :param str device_type_id__n: 
        :param str role_id__n: 
        :param str role__n: 
        :param str platform_id__n: 
        :param str platform__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str rack_group_id__n: 
        :param str rack_id__n: 
        :param str cluster_id__n: 
        :param str model__n: 
        :param str status__n: 
        :param str mac_address__n: 
        :param str mac_address__ic: 
        :param str mac_address__nic: 
        :param str mac_address__iew: 
        :param str mac_address__niew: 
        :param str mac_address__isw: 
        :param str mac_address__nisw: 
        :param str mac_address__ie: 
        :param str mac_address__nie: 
        :param str virtual_chassis_id__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_devices_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_devices_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_devices_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_devices_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str asset_tag: 
        :param str face: 
        :param str position: 
        :param str vc_position: 
        :param str vc_priority: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str local_context_data: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str manufacturer_id: 
        :param str manufacturer: 
        :param str device_type_id: 
        :param str role_id: 
        :param str role: 
        :param str platform_id: 
        :param str platform: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str rack_group_id: 
        :param str rack_id: 
        :param str cluster_id: 
        :param str model: 
        :param str status: 
        :param str is_full_depth: 
        :param str mac_address: 
        :param str serial: 
        :param str has_primary_ip: 
        :param str virtual_chassis_id: 
        :param str virtual_chassis_member: 
        :param str console_ports: 
        :param str console_server_ports: 
        :param str power_ports: 
        :param str power_outlets: 
        :param str interfaces: 
        :param str pass_through_ports: 
        :param str device_bays: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str asset_tag__n: 
        :param str asset_tag__ic: 
        :param str asset_tag__nic: 
        :param str asset_tag__iew: 
        :param str asset_tag__niew: 
        :param str asset_tag__isw: 
        :param str asset_tag__nisw: 
        :param str asset_tag__ie: 
        :param str asset_tag__nie: 
        :param str face__n: 
        :param str position__n: 
        :param str position__lte: 
        :param str position__lt: 
        :param str position__gte: 
        :param str position__gt: 
        :param str vc_position__n: 
        :param str vc_position__lte: 
        :param str vc_position__lt: 
        :param str vc_position__gte: 
        :param str vc_position__gt: 
        :param str vc_priority__n: 
        :param str vc_priority__lte: 
        :param str vc_priority__lt: 
        :param str vc_priority__gte: 
        :param str vc_priority__gt: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str manufacturer_id__n: 
        :param str manufacturer__n: 
        :param str device_type_id__n: 
        :param str role_id__n: 
        :param str role__n: 
        :param str platform_id__n: 
        :param str platform__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str rack_group_id__n: 
        :param str rack_id__n: 
        :param str cluster_id__n: 
        :param str model__n: 
        :param str status__n: 
        :param str mac_address__n: 
        :param str mac_address__ic: 
        :param str mac_address__nic: 
        :param str mac_address__iew: 
        :param str mac_address__niew: 
        :param str mac_address__isw: 
        :param str mac_address__nisw: 
        :param str mac_address__ie: 
        :param str mac_address__nie: 
        :param str virtual_chassis_id__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'asset_tag', 'face', 'position', 'vc_position', 'vc_priority', 'tenant_group_id', 'tenant_group', 'tenant_id', 'tenant', 'local_context_data', 'created', 'created__gte', 'created__lte', 'last_updated', 'last_updated__gte', 'last_updated__lte', 'q', 'manufacturer_id', 'manufacturer', 'device_type_id', 'role_id', 'role', 'platform_id', 'platform', 'region_id', 'region', 'site_id', 'site', 'rack_group_id', 'rack_id', 'cluster_id', 'model', 'status', 'is_full_depth', 'mac_address', 'serial', 'has_primary_ip', 'virtual_chassis_id', 'virtual_chassis_member', 'console_ports', 'console_server_ports', 'power_ports', 'power_outlets', 'interfaces', 'pass_through_ports', 'device_bays', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'asset_tag__n', 'asset_tag__ic', 'asset_tag__nic', 'asset_tag__iew', 'asset_tag__niew', 'asset_tag__isw', 'asset_tag__nisw', 'asset_tag__ie', 'asset_tag__nie', 'face__n', 'position__n', 'position__lte', 'position__lt', 'position__gte', 'position__gt', 'vc_position__n', 'vc_position__lte', 'vc_position__lt', 'vc_position__gte', 'vc_position__gt', 'vc_priority__n', 'vc_priority__lte', 'vc_priority__lt', 'vc_priority__gte', 'vc_priority__gt', 'tenant_group_id__n', 'tenant_group__n', 'tenant_id__n', 'tenant__n', 'manufacturer_id__n', 'manufacturer__n', 'device_type_id__n', 'role_id__n', 'role__n', 'platform_id__n', 'platform__n', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'rack_group_id__n', 'rack_id__n', 'cluster_id__n', 'model__n', 'status__n', 'mac_address__n', 'mac_address__ic', 'mac_address__nic', 'mac_address__iew', 'mac_address__niew', 'mac_address__isw', 'mac_address__nisw', 'mac_address__ie', 'mac_address__nie', 'virtual_chassis_id__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_devices_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'asset_tag' in params:
            query_params.append(('asset_tag', params['asset_tag']))  # noqa: E501
        if 'face' in params:
            query_params.append(('face', params['face']))  # noqa: E501
        if 'position' in params:
            query_params.append(('position', params['position']))  # noqa: E501
        if 'vc_position' in params:
            query_params.append(('vc_position', params['vc_position']))  # noqa: E501
        if 'vc_priority' in params:
            query_params.append(('vc_priority', params['vc_priority']))  # noqa: E501
        if 'tenant_group_id' in params:
            query_params.append(('tenant_group_id', params['tenant_group_id']))  # noqa: E501
        if 'tenant_group' in params:
            query_params.append(('tenant_group', params['tenant_group']))  # noqa: E501
        if 'tenant_id' in params:
            query_params.append(('tenant_id', params['tenant_id']))  # noqa: E501
        if 'tenant' in params:
            query_params.append(('tenant', params['tenant']))  # noqa: E501
        if 'local_context_data' in params:
            query_params.append(('local_context_data', params['local_context_data']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('created__gte', params['created__gte']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('created__lte', params['created__lte']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('last_updated', params['last_updated']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'manufacturer_id' in params:
            query_params.append(('manufacturer_id', params['manufacturer_id']))  # noqa: E501
        if 'manufacturer' in params:
            query_params.append(('manufacturer', params['manufacturer']))  # noqa: E501
        if 'device_type_id' in params:
            query_params.append(('device_type_id', params['device_type_id']))  # noqa: E501
        if 'role_id' in params:
            query_params.append(('role_id', params['role_id']))  # noqa: E501
        if 'role' in params:
            query_params.append(('role', params['role']))  # noqa: E501
        if 'platform_id' in params:
            query_params.append(('platform_id', params['platform_id']))  # noqa: E501
        if 'platform' in params:
            query_params.append(('platform', params['platform']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'rack_group_id' in params:
            query_params.append(('rack_group_id', params['rack_group_id']))  # noqa: E501
        if 'rack_id' in params:
            query_params.append(('rack_id', params['rack_id']))  # noqa: E501
        if 'cluster_id' in params:
            query_params.append(('cluster_id', params['cluster_id']))  # noqa: E501
        if 'model' in params:
            query_params.append(('model', params['model']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'is_full_depth' in params:
            query_params.append(('is_full_depth', params['is_full_depth']))  # noqa: E501
        if 'mac_address' in params:
            query_params.append(('mac_address', params['mac_address']))  # noqa: E501
        if 'serial' in params:
            query_params.append(('serial', params['serial']))  # noqa: E501
        if 'has_primary_ip' in params:
            query_params.append(('has_primary_ip', params['has_primary_ip']))  # noqa: E501
        if 'virtual_chassis_id' in params:
            query_params.append(('virtual_chassis_id', params['virtual_chassis_id']))  # noqa: E501
        if 'virtual_chassis_member' in params:
            query_params.append(('virtual_chassis_member', params['virtual_chassis_member']))  # noqa: E501
        if 'console_ports' in params:
            query_params.append(('console_ports', params['console_ports']))  # noqa: E501
        if 'console_server_ports' in params:
            query_params.append(('console_server_ports', params['console_server_ports']))  # noqa: E501
        if 'power_ports' in params:
            query_params.append(('power_ports', params['power_ports']))  # noqa: E501
        if 'power_outlets' in params:
            query_params.append(('power_outlets', params['power_outlets']))  # noqa: E501
        if 'interfaces' in params:
            query_params.append(('interfaces', params['interfaces']))  # noqa: E501
        if 'pass_through_ports' in params:
            query_params.append(('pass_through_ports', params['pass_through_ports']))  # noqa: E501
        if 'device_bays' in params:
            query_params.append(('device_bays', params['device_bays']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'asset_tag__n' in params:
            query_params.append(('asset_tag__n', params['asset_tag__n']))  # noqa: E501
        if 'asset_tag__ic' in params:
            query_params.append(('asset_tag__ic', params['asset_tag__ic']))  # noqa: E501
        if 'asset_tag__nic' in params:
            query_params.append(('asset_tag__nic', params['asset_tag__nic']))  # noqa: E501
        if 'asset_tag__iew' in params:
            query_params.append(('asset_tag__iew', params['asset_tag__iew']))  # noqa: E501
        if 'asset_tag__niew' in params:
            query_params.append(('asset_tag__niew', params['asset_tag__niew']))  # noqa: E501
        if 'asset_tag__isw' in params:
            query_params.append(('asset_tag__isw', params['asset_tag__isw']))  # noqa: E501
        if 'asset_tag__nisw' in params:
            query_params.append(('asset_tag__nisw', params['asset_tag__nisw']))  # noqa: E501
        if 'asset_tag__ie' in params:
            query_params.append(('asset_tag__ie', params['asset_tag__ie']))  # noqa: E501
        if 'asset_tag__nie' in params:
            query_params.append(('asset_tag__nie', params['asset_tag__nie']))  # noqa: E501
        if 'face__n' in params:
            query_params.append(('face__n', params['face__n']))  # noqa: E501
        if 'position__n' in params:
            query_params.append(('position__n', params['position__n']))  # noqa: E501
        if 'position__lte' in params:
            query_params.append(('position__lte', params['position__lte']))  # noqa: E501
        if 'position__lt' in params:
            query_params.append(('position__lt', params['position__lt']))  # noqa: E501
        if 'position__gte' in params:
            query_params.append(('position__gte', params['position__gte']))  # noqa: E501
        if 'position__gt' in params:
            query_params.append(('position__gt', params['position__gt']))  # noqa: E501
        if 'vc_position__n' in params:
            query_params.append(('vc_position__n', params['vc_position__n']))  # noqa: E501
        if 'vc_position__lte' in params:
            query_params.append(('vc_position__lte', params['vc_position__lte']))  # noqa: E501
        if 'vc_position__lt' in params:
            query_params.append(('vc_position__lt', params['vc_position__lt']))  # noqa: E501
        if 'vc_position__gte' in params:
            query_params.append(('vc_position__gte', params['vc_position__gte']))  # noqa: E501
        if 'vc_position__gt' in params:
            query_params.append(('vc_position__gt', params['vc_position__gt']))  # noqa: E501
        if 'vc_priority__n' in params:
            query_params.append(('vc_priority__n', params['vc_priority__n']))  # noqa: E501
        if 'vc_priority__lte' in params:
            query_params.append(('vc_priority__lte', params['vc_priority__lte']))  # noqa: E501
        if 'vc_priority__lt' in params:
            query_params.append(('vc_priority__lt', params['vc_priority__lt']))  # noqa: E501
        if 'vc_priority__gte' in params:
            query_params.append(('vc_priority__gte', params['vc_priority__gte']))  # noqa: E501
        if 'vc_priority__gt' in params:
            query_params.append(('vc_priority__gt', params['vc_priority__gt']))  # noqa: E501
        if 'tenant_group_id__n' in params:
            query_params.append(('tenant_group_id__n', params['tenant_group_id__n']))  # noqa: E501
        if 'tenant_group__n' in params:
            query_params.append(('tenant_group__n', params['tenant_group__n']))  # noqa: E501
        if 'tenant_id__n' in params:
            query_params.append(('tenant_id__n', params['tenant_id__n']))  # noqa: E501
        if 'tenant__n' in params:
            query_params.append(('tenant__n', params['tenant__n']))  # noqa: E501
        if 'manufacturer_id__n' in params:
            query_params.append(('manufacturer_id__n', params['manufacturer_id__n']))  # noqa: E501
        if 'manufacturer__n' in params:
            query_params.append(('manufacturer__n', params['manufacturer__n']))  # noqa: E501
        if 'device_type_id__n' in params:
            query_params.append(('device_type_id__n', params['device_type_id__n']))  # noqa: E501
        if 'role_id__n' in params:
            query_params.append(('role_id__n', params['role_id__n']))  # noqa: E501
        if 'role__n' in params:
            query_params.append(('role__n', params['role__n']))  # noqa: E501
        if 'platform_id__n' in params:
            query_params.append(('platform_id__n', params['platform_id__n']))  # noqa: E501
        if 'platform__n' in params:
            query_params.append(('platform__n', params['platform__n']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'rack_group_id__n' in params:
            query_params.append(('rack_group_id__n', params['rack_group_id__n']))  # noqa: E501
        if 'rack_id__n' in params:
            query_params.append(('rack_id__n', params['rack_id__n']))  # noqa: E501
        if 'cluster_id__n' in params:
            query_params.append(('cluster_id__n', params['cluster_id__n']))  # noqa: E501
        if 'model__n' in params:
            query_params.append(('model__n', params['model__n']))  # noqa: E501
        if 'status__n' in params:
            query_params.append(('status__n', params['status__n']))  # noqa: E501
        if 'mac_address__n' in params:
            query_params.append(('mac_address__n', params['mac_address__n']))  # noqa: E501
        if 'mac_address__ic' in params:
            query_params.append(('mac_address__ic', params['mac_address__ic']))  # noqa: E501
        if 'mac_address__nic' in params:
            query_params.append(('mac_address__nic', params['mac_address__nic']))  # noqa: E501
        if 'mac_address__iew' in params:
            query_params.append(('mac_address__iew', params['mac_address__iew']))  # noqa: E501
        if 'mac_address__niew' in params:
            query_params.append(('mac_address__niew', params['mac_address__niew']))  # noqa: E501
        if 'mac_address__isw' in params:
            query_params.append(('mac_address__isw', params['mac_address__isw']))  # noqa: E501
        if 'mac_address__nisw' in params:
            query_params.append(('mac_address__nisw', params['mac_address__nisw']))  # noqa: E501
        if 'mac_address__ie' in params:
            query_params.append(('mac_address__ie', params['mac_address__ie']))  # noqa: E501
        if 'mac_address__nie' in params:
            query_params.append(('mac_address__nie', params['mac_address__nie']))  # noqa: E501
        if 'virtual_chassis_id__n' in params:
            query_params.append(('virtual_chassis_id__n', params['virtual_chassis_id__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/devices/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_devices_napalm(self, id, method, **kwargs):  # noqa: E501
        """dcim_devices_napalm  # noqa: E501

        Execute a NAPALM method on a Device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_napalm(id, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :param str method: (required)
        :return: DeviceNAPALM
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_devices_napalm_with_http_info(id, method, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_devices_napalm_with_http_info(id, method, **kwargs)  # noqa: E501
            return data

    def dcim_devices_napalm_with_http_info(self, id, method, **kwargs):  # noqa: E501
        """dcim_devices_napalm  # noqa: E501

        Execute a NAPALM method on a Device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_napalm_with_http_info(id, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :param str method: (required)
        :return: DeviceNAPALM
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'method']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_devices_napalm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_devices_napalm`")  # noqa: E501
        # verify the required parameter 'method' is set
        if ('method' not in params or
                params['method'] is None):
            raise ValueError("Missing the required parameter `method` when calling `dcim_devices_napalm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/devices/{id}/napalm/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceNAPALM',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_devices_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_devices_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :param WritableDeviceWithConfigContext data: (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_devices_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_devices_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_devices_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_devices_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :param WritableDeviceWithConfigContext data: (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_devices_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_devices_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_devices_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/devices/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceWithConfigContext',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_devices_read(self, id, **kwargs):  # noqa: E501
        """dcim_devices_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_devices_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_devices_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_devices_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_devices_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_devices_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_devices_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/devices/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceWithConfigContext',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_devices_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_devices_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :param WritableDeviceWithConfigContext data: (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_devices_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_devices_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_devices_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_devices_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_devices_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this device. (required)
        :param WritableDeviceWithConfigContext data: (required)
        :return: DeviceWithConfigContext
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_devices_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_devices_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_devices_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/devices/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceWithConfigContext',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_port_templates_create(self, data, **kwargs):  # noqa: E501
        """dcim_front_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableFrontPortTemplate data: (required)
        :return: FrontPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_front_port_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_front_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableFrontPortTemplate data: (required)
        :return: FrontPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_port_templates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_front_port_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-port-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_port_templates_delete(self, id, **kwargs):  # noqa: E501
        """dcim_front_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_front_port_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_front_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_port_templates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_front_port_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-port-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_port_templates_list(self, **kwargs):  # noqa: E501
        """dcim_front_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_port_templates_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_port_templates_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_front_port_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_front_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'q', 'devicetype_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'devicetype_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_port_templates_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'devicetype_id' in params:
            query_params.append(('devicetype_id', params['devicetype_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'devicetype_id__n' in params:
            query_params.append(('devicetype_id__n', params['devicetype_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-port-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_port_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_front_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port template. (required)
        :param WritableFrontPortTemplate data: (required)
        :return: FrontPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_front_port_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_front_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port template. (required)
        :param WritableFrontPortTemplate data: (required)
        :return: FrontPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_port_templates_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_front_port_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_front_port_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-port-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_port_templates_read(self, id, **kwargs):  # noqa: E501
        """dcim_front_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port template. (required)
        :return: FrontPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_front_port_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_front_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port template. (required)
        :return: FrontPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_port_templates_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_front_port_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-port-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_port_templates_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_front_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port template. (required)
        :param WritableFrontPortTemplate data: (required)
        :return: FrontPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_front_port_templates_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_front_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_port_templates_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port template. (required)
        :param WritableFrontPortTemplate data: (required)
        :return: FrontPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_port_templates_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_front_port_templates_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_front_port_templates_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-port-templates/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_ports_create(self, data, **kwargs):  # noqa: E501
        """dcim_front_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableFrontPort data: (required)
        :return: FrontPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_ports_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_ports_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_front_ports_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_front_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableFrontPort data: (required)
        :return: FrontPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_ports_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_front_ports_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-ports/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_ports_delete(self, id, **kwargs):  # noqa: E501
        """dcim_front_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_front_ports_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_front_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_ports_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_front_ports_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-ports/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_ports_list(self, **kwargs):  # noqa: E501
        """dcim_front_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_ports_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_ports_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_front_ports_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_front_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'description', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'cabled', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'device_id__n', 'device__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_ports_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'cabled' in params:
            query_params.append(('cabled', params['cabled']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'device_id__n' in params:
            query_params.append(('device_id__n', params['device_id__n']))  # noqa: E501
        if 'device__n' in params:
            query_params.append(('device__n', params['device__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-ports/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_ports_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_front_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port. (required)
        :param WritableFrontPort data: (required)
        :return: FrontPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_front_ports_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_front_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port. (required)
        :param WritableFrontPort data: (required)
        :return: FrontPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_ports_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_front_ports_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_front_ports_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-ports/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_ports_read(self, id, **kwargs):  # noqa: E501
        """dcim_front_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port. (required)
        :return: FrontPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_ports_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_ports_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_front_ports_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_front_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port. (required)
        :return: FrontPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_ports_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_front_ports_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-ports/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_front_ports_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_front_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port. (required)
        :param WritableFrontPort data: (required)
        :return: FrontPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_front_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_front_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_front_ports_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_front_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_front_ports_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this front port. (required)
        :param WritableFrontPort data: (required)
        :return: FrontPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_front_ports_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_front_ports_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_front_ports_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/front-ports/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interface_connections_list(self, **kwargs):  # noqa: E501
        """dcim_interface_connections_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_connections_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_status: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str connection_status__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interface_connections_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interface_connections_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_interface_connections_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_interface_connections_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_connections_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_status: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str connection_status__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connection_status', 'site', 'device_id', 'device', 'connection_status__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interface_connections_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'connection_status' in params:
            query_params.append(('connection_status', params['connection_status']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'connection_status__n' in params:
            query_params.append(('connection_status__n', params['connection_status__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interface-connections/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interface_templates_create(self, data, **kwargs):  # noqa: E501
        """dcim_interface_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableInterfaceTemplate data: (required)
        :return: InterfaceTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interface_templates_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interface_templates_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_interface_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_interface_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableInterfaceTemplate data: (required)
        :return: InterfaceTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interface_templates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_interface_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interface-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interface_templates_delete(self, id, **kwargs):  # noqa: E501
        """dcim_interface_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interface_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interface_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_interface_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_interface_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interface_templates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interface_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interface-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interface_templates_list(self, **kwargs):  # noqa: E501
        """dcim_interface_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str mgmt_only: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interface_templates_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interface_templates_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_interface_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_interface_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str mgmt_only: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'mgmt_only', 'q', 'devicetype_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'devicetype_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interface_templates_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'mgmt_only' in params:
            query_params.append(('mgmt_only', params['mgmt_only']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'devicetype_id' in params:
            query_params.append(('devicetype_id', params['devicetype_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'devicetype_id__n' in params:
            query_params.append(('devicetype_id__n', params['devicetype_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interface-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interface_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_interface_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface template. (required)
        :param WritableInterfaceTemplate data: (required)
        :return: InterfaceTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interface_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interface_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_interface_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_interface_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface template. (required)
        :param WritableInterfaceTemplate data: (required)
        :return: InterfaceTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interface_templates_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interface_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_interface_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interface-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interface_templates_read(self, id, **kwargs):  # noqa: E501
        """dcim_interface_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface template. (required)
        :return: InterfaceTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interface_templates_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interface_templates_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_interface_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_interface_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface template. (required)
        :return: InterfaceTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interface_templates_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interface_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interface-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interface_templates_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_interface_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface template. (required)
        :param WritableInterfaceTemplate data: (required)
        :return: InterfaceTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interface_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interface_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_interface_templates_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_interface_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interface_templates_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface template. (required)
        :param WritableInterfaceTemplate data: (required)
        :return: InterfaceTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interface_templates_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interface_templates_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_interface_templates_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interface-templates/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interfaces_create(self, data, **kwargs):  # noqa: E501
        """dcim_interfaces_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceInterface data: (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interfaces_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interfaces_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_interfaces_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_interfaces_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableDeviceInterface data: (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interfaces_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_interfaces_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interfaces/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interfaces_delete(self, id, **kwargs):  # noqa: E501
        """dcim_interfaces_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interfaces_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interfaces_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_interfaces_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_interfaces_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interfaces_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interfaces_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interfaces/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interfaces_graphs(self, id, **kwargs):  # noqa: E501
        """dcim_interfaces_graphs  # noqa: E501

        A convenience method for rendering graphs for a particular interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_graphs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interfaces_graphs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interfaces_graphs_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_interfaces_graphs_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_interfaces_graphs  # noqa: E501

        A convenience method for rendering graphs for a particular interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_graphs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interfaces_graphs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interfaces_graphs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interfaces/{id}/graphs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interfaces_list(self, **kwargs):  # noqa: E501
        """dcim_interfaces_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str connection_status: 
        :param str type: 
        :param str enabled: 
        :param str mtu: 
        :param str mgmt_only: 
        :param str mode: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str cabled: 
        :param str kind: 
        :param str lag_id: 
        :param str mac_address: 
        :param str vlan_id: 
        :param str vlan: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str connection_status__n: 
        :param str type__n: 
        :param str mtu__n: 
        :param str mtu__lte: 
        :param str mtu__lt: 
        :param str mtu__gte: 
        :param str mtu__gt: 
        :param str mode__n: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str tag__n: 
        :param str lag_id__n: 
        :param str mac_address__n: 
        :param str mac_address__ic: 
        :param str mac_address__nic: 
        :param str mac_address__iew: 
        :param str mac_address__niew: 
        :param str mac_address__isw: 
        :param str mac_address__nisw: 
        :param str mac_address__ie: 
        :param str mac_address__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interfaces_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interfaces_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_interfaces_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_interfaces_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str connection_status: 
        :param str type: 
        :param str enabled: 
        :param str mtu: 
        :param str mgmt_only: 
        :param str mode: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str cabled: 
        :param str kind: 
        :param str lag_id: 
        :param str mac_address: 
        :param str vlan_id: 
        :param str vlan: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str connection_status__n: 
        :param str type__n: 
        :param str mtu__n: 
        :param str mtu__lte: 
        :param str mtu__lt: 
        :param str mtu__gte: 
        :param str mtu__gt: 
        :param str mode__n: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str tag__n: 
        :param str lag_id__n: 
        :param str mac_address__n: 
        :param str mac_address__ic: 
        :param str mac_address__nic: 
        :param str mac_address__iew: 
        :param str mac_address__niew: 
        :param str mac_address__isw: 
        :param str mac_address__nisw: 
        :param str mac_address__ie: 
        :param str mac_address__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'connection_status', 'type', 'enabled', 'mtu', 'mgmt_only', 'mode', 'description', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'cabled', 'kind', 'lag_id', 'mac_address', 'vlan_id', 'vlan', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'connection_status__n', 'type__n', 'mtu__n', 'mtu__lte', 'mtu__lt', 'mtu__gte', 'mtu__gt', 'mode__n', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'tag__n', 'lag_id__n', 'mac_address__n', 'mac_address__ic', 'mac_address__nic', 'mac_address__iew', 'mac_address__niew', 'mac_address__isw', 'mac_address__nisw', 'mac_address__ie', 'mac_address__nie', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interfaces_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'connection_status' in params:
            query_params.append(('connection_status', params['connection_status']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'enabled' in params:
            query_params.append(('enabled', params['enabled']))  # noqa: E501
        if 'mtu' in params:
            query_params.append(('mtu', params['mtu']))  # noqa: E501
        if 'mgmt_only' in params:
            query_params.append(('mgmt_only', params['mgmt_only']))  # noqa: E501
        if 'mode' in params:
            query_params.append(('mode', params['mode']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'cabled' in params:
            query_params.append(('cabled', params['cabled']))  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501
        if 'lag_id' in params:
            query_params.append(('lag_id', params['lag_id']))  # noqa: E501
        if 'mac_address' in params:
            query_params.append(('mac_address', params['mac_address']))  # noqa: E501
        if 'vlan_id' in params:
            query_params.append(('vlan_id', params['vlan_id']))  # noqa: E501
        if 'vlan' in params:
            query_params.append(('vlan', params['vlan']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'connection_status__n' in params:
            query_params.append(('connection_status__n', params['connection_status__n']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'mtu__n' in params:
            query_params.append(('mtu__n', params['mtu__n']))  # noqa: E501
        if 'mtu__lte' in params:
            query_params.append(('mtu__lte', params['mtu__lte']))  # noqa: E501
        if 'mtu__lt' in params:
            query_params.append(('mtu__lt', params['mtu__lt']))  # noqa: E501
        if 'mtu__gte' in params:
            query_params.append(('mtu__gte', params['mtu__gte']))  # noqa: E501
        if 'mtu__gt' in params:
            query_params.append(('mtu__gt', params['mtu__gt']))  # noqa: E501
        if 'mode__n' in params:
            query_params.append(('mode__n', params['mode__n']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'lag_id__n' in params:
            query_params.append(('lag_id__n', params['lag_id__n']))  # noqa: E501
        if 'mac_address__n' in params:
            query_params.append(('mac_address__n', params['mac_address__n']))  # noqa: E501
        if 'mac_address__ic' in params:
            query_params.append(('mac_address__ic', params['mac_address__ic']))  # noqa: E501
        if 'mac_address__nic' in params:
            query_params.append(('mac_address__nic', params['mac_address__nic']))  # noqa: E501
        if 'mac_address__iew' in params:
            query_params.append(('mac_address__iew', params['mac_address__iew']))  # noqa: E501
        if 'mac_address__niew' in params:
            query_params.append(('mac_address__niew', params['mac_address__niew']))  # noqa: E501
        if 'mac_address__isw' in params:
            query_params.append(('mac_address__isw', params['mac_address__isw']))  # noqa: E501
        if 'mac_address__nisw' in params:
            query_params.append(('mac_address__nisw', params['mac_address__nisw']))  # noqa: E501
        if 'mac_address__ie' in params:
            query_params.append(('mac_address__ie', params['mac_address__ie']))  # noqa: E501
        if 'mac_address__nie' in params:
            query_params.append(('mac_address__nie', params['mac_address__nie']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interfaces/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interfaces_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_interfaces_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :param WritableDeviceInterface data: (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interfaces_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interfaces_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_interfaces_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_interfaces_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :param WritableDeviceInterface data: (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interfaces_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interfaces_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_interfaces_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interfaces/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interfaces_read(self, id, **kwargs):  # noqa: E501
        """dcim_interfaces_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interfaces_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interfaces_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_interfaces_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_interfaces_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interfaces_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interfaces_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interfaces/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interfaces_trace(self, id, **kwargs):  # noqa: E501
        """dcim_interfaces_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_trace(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interfaces_trace_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interfaces_trace_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_interfaces_trace_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_interfaces_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_trace_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interfaces_trace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interfaces_trace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interfaces/{id}/trace/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_interfaces_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_interfaces_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :param WritableDeviceInterface data: (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_interfaces_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_interfaces_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_interfaces_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_interfaces_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_interfaces_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this interface. (required)
        :param WritableDeviceInterface data: (required)
        :return: DeviceInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_interfaces_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_interfaces_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_interfaces_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/interfaces/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_inventory_items_create(self, data, **kwargs):  # noqa: E501
        """dcim_inventory_items_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableInventoryItem data: (required)
        :return: InventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_inventory_items_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_inventory_items_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_inventory_items_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_inventory_items_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableInventoryItem data: (required)
        :return: InventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_inventory_items_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_inventory_items_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/inventory-items/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_inventory_items_delete(self, id, **kwargs):  # noqa: E501
        """dcim_inventory_items_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this inventory item. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_inventory_items_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_inventory_items_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_inventory_items_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_inventory_items_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this inventory item. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_inventory_items_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_inventory_items_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/inventory-items/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_inventory_items_list(self, **kwargs):  # noqa: E501
        """dcim_inventory_items_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str part_id: 
        :param str asset_tag: 
        :param str discovered: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str parent_id: 
        :param str manufacturer_id: 
        :param str manufacturer: 
        :param str serial: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str part_id__n: 
        :param str part_id__ic: 
        :param str part_id__nic: 
        :param str part_id__iew: 
        :param str part_id__niew: 
        :param str part_id__isw: 
        :param str part_id__nisw: 
        :param str part_id__ie: 
        :param str part_id__nie: 
        :param str asset_tag__n: 
        :param str asset_tag__ic: 
        :param str asset_tag__nic: 
        :param str asset_tag__iew: 
        :param str asset_tag__niew: 
        :param str asset_tag__isw: 
        :param str asset_tag__nisw: 
        :param str asset_tag__ie: 
        :param str asset_tag__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str parent_id__n: 
        :param str manufacturer_id__n: 
        :param str manufacturer__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_inventory_items_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_inventory_items_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_inventory_items_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_inventory_items_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str part_id: 
        :param str asset_tag: 
        :param str discovered: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str parent_id: 
        :param str manufacturer_id: 
        :param str manufacturer: 
        :param str serial: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str part_id__n: 
        :param str part_id__ic: 
        :param str part_id__nic: 
        :param str part_id__iew: 
        :param str part_id__niew: 
        :param str part_id__isw: 
        :param str part_id__nisw: 
        :param str part_id__ie: 
        :param str part_id__nie: 
        :param str asset_tag__n: 
        :param str asset_tag__ic: 
        :param str asset_tag__nic: 
        :param str asset_tag__iew: 
        :param str asset_tag__niew: 
        :param str asset_tag__isw: 
        :param str asset_tag__nisw: 
        :param str asset_tag__ie: 
        :param str asset_tag__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str parent_id__n: 
        :param str manufacturer_id__n: 
        :param str manufacturer__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'part_id', 'asset_tag', 'discovered', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'parent_id', 'manufacturer_id', 'manufacturer', 'serial', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'part_id__n', 'part_id__ic', 'part_id__nic', 'part_id__iew', 'part_id__niew', 'part_id__isw', 'part_id__nisw', 'part_id__ie', 'part_id__nie', 'asset_tag__n', 'asset_tag__ic', 'asset_tag__nic', 'asset_tag__iew', 'asset_tag__niew', 'asset_tag__isw', 'asset_tag__nisw', 'asset_tag__ie', 'asset_tag__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'device_id__n', 'device__n', 'tag__n', 'parent_id__n', 'manufacturer_id__n', 'manufacturer__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_inventory_items_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'part_id' in params:
            query_params.append(('part_id', params['part_id']))  # noqa: E501
        if 'asset_tag' in params:
            query_params.append(('asset_tag', params['asset_tag']))  # noqa: E501
        if 'discovered' in params:
            query_params.append(('discovered', params['discovered']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'parent_id' in params:
            query_params.append(('parent_id', params['parent_id']))  # noqa: E501
        if 'manufacturer_id' in params:
            query_params.append(('manufacturer_id', params['manufacturer_id']))  # noqa: E501
        if 'manufacturer' in params:
            query_params.append(('manufacturer', params['manufacturer']))  # noqa: E501
        if 'serial' in params:
            query_params.append(('serial', params['serial']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'part_id__n' in params:
            query_params.append(('part_id__n', params['part_id__n']))  # noqa: E501
        if 'part_id__ic' in params:
            query_params.append(('part_id__ic', params['part_id__ic']))  # noqa: E501
        if 'part_id__nic' in params:
            query_params.append(('part_id__nic', params['part_id__nic']))  # noqa: E501
        if 'part_id__iew' in params:
            query_params.append(('part_id__iew', params['part_id__iew']))  # noqa: E501
        if 'part_id__niew' in params:
            query_params.append(('part_id__niew', params['part_id__niew']))  # noqa: E501
        if 'part_id__isw' in params:
            query_params.append(('part_id__isw', params['part_id__isw']))  # noqa: E501
        if 'part_id__nisw' in params:
            query_params.append(('part_id__nisw', params['part_id__nisw']))  # noqa: E501
        if 'part_id__ie' in params:
            query_params.append(('part_id__ie', params['part_id__ie']))  # noqa: E501
        if 'part_id__nie' in params:
            query_params.append(('part_id__nie', params['part_id__nie']))  # noqa: E501
        if 'asset_tag__n' in params:
            query_params.append(('asset_tag__n', params['asset_tag__n']))  # noqa: E501
        if 'asset_tag__ic' in params:
            query_params.append(('asset_tag__ic', params['asset_tag__ic']))  # noqa: E501
        if 'asset_tag__nic' in params:
            query_params.append(('asset_tag__nic', params['asset_tag__nic']))  # noqa: E501
        if 'asset_tag__iew' in params:
            query_params.append(('asset_tag__iew', params['asset_tag__iew']))  # noqa: E501
        if 'asset_tag__niew' in params:
            query_params.append(('asset_tag__niew', params['asset_tag__niew']))  # noqa: E501
        if 'asset_tag__isw' in params:
            query_params.append(('asset_tag__isw', params['asset_tag__isw']))  # noqa: E501
        if 'asset_tag__nisw' in params:
            query_params.append(('asset_tag__nisw', params['asset_tag__nisw']))  # noqa: E501
        if 'asset_tag__ie' in params:
            query_params.append(('asset_tag__ie', params['asset_tag__ie']))  # noqa: E501
        if 'asset_tag__nie' in params:
            query_params.append(('asset_tag__nie', params['asset_tag__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'device_id__n' in params:
            query_params.append(('device_id__n', params['device_id__n']))  # noqa: E501
        if 'device__n' in params:
            query_params.append(('device__n', params['device__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'parent_id__n' in params:
            query_params.append(('parent_id__n', params['parent_id__n']))  # noqa: E501
        if 'manufacturer_id__n' in params:
            query_params.append(('manufacturer_id__n', params['manufacturer_id__n']))  # noqa: E501
        if 'manufacturer__n' in params:
            query_params.append(('manufacturer__n', params['manufacturer__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/inventory-items/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_inventory_items_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_inventory_items_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this inventory item. (required)
        :param WritableInventoryItem data: (required)
        :return: InventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_inventory_items_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_inventory_items_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_inventory_items_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_inventory_items_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this inventory item. (required)
        :param WritableInventoryItem data: (required)
        :return: InventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_inventory_items_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_inventory_items_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_inventory_items_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/inventory-items/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_inventory_items_read(self, id, **kwargs):  # noqa: E501
        """dcim_inventory_items_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this inventory item. (required)
        :return: InventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_inventory_items_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_inventory_items_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_inventory_items_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_inventory_items_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this inventory item. (required)
        :return: InventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_inventory_items_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_inventory_items_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/inventory-items/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_inventory_items_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_inventory_items_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this inventory item. (required)
        :param WritableInventoryItem data: (required)
        :return: InventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_inventory_items_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_inventory_items_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_inventory_items_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_inventory_items_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_inventory_items_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this inventory item. (required)
        :param WritableInventoryItem data: (required)
        :return: InventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_inventory_items_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_inventory_items_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_inventory_items_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/inventory-items/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_manufacturers_create(self, data, **kwargs):  # noqa: E501
        """dcim_manufacturers_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Manufacturer data: (required)
        :return: Manufacturer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_manufacturers_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_manufacturers_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_manufacturers_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_manufacturers_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Manufacturer data: (required)
        :return: Manufacturer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_manufacturers_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_manufacturers_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/manufacturers/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Manufacturer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_manufacturers_delete(self, id, **kwargs):  # noqa: E501
        """dcim_manufacturers_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this manufacturer. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_manufacturers_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_manufacturers_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_manufacturers_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_manufacturers_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this manufacturer. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_manufacturers_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_manufacturers_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/manufacturers/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_manufacturers_list(self, **kwargs):  # noqa: E501
        """dcim_manufacturers_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str description: 
        :param str q: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_manufacturers_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_manufacturers_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_manufacturers_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_manufacturers_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str description: 
        :param str q: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'description', 'q', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_manufacturers_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/manufacturers/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_manufacturers_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_manufacturers_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this manufacturer. (required)
        :param Manufacturer data: (required)
        :return: Manufacturer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_manufacturers_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_manufacturers_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_manufacturers_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_manufacturers_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this manufacturer. (required)
        :param Manufacturer data: (required)
        :return: Manufacturer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_manufacturers_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_manufacturers_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_manufacturers_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/manufacturers/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Manufacturer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_manufacturers_read(self, id, **kwargs):  # noqa: E501
        """dcim_manufacturers_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this manufacturer. (required)
        :return: Manufacturer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_manufacturers_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_manufacturers_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_manufacturers_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_manufacturers_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this manufacturer. (required)
        :return: Manufacturer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_manufacturers_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_manufacturers_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/manufacturers/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Manufacturer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_manufacturers_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_manufacturers_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this manufacturer. (required)
        :param Manufacturer data: (required)
        :return: Manufacturer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_manufacturers_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_manufacturers_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_manufacturers_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_manufacturers_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_manufacturers_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this manufacturer. (required)
        :param Manufacturer data: (required)
        :return: Manufacturer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_manufacturers_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_manufacturers_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_manufacturers_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/manufacturers/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Manufacturer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_platforms_create(self, data, **kwargs):  # noqa: E501
        """dcim_platforms_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePlatform data: (required)
        :return: Platform
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_platforms_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_platforms_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_platforms_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_platforms_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePlatform data: (required)
        :return: Platform
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_platforms_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_platforms_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/platforms/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Platform',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_platforms_delete(self, id, **kwargs):  # noqa: E501
        """dcim_platforms_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this platform. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_platforms_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_platforms_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_platforms_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_platforms_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this platform. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_platforms_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_platforms_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/platforms/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_platforms_list(self, **kwargs):  # noqa: E501
        """dcim_platforms_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str napalm_driver: 
        :param str description: 
        :param str q: 
        :param str manufacturer_id: 
        :param str manufacturer: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str napalm_driver__n: 
        :param str napalm_driver__ic: 
        :param str napalm_driver__nic: 
        :param str napalm_driver__iew: 
        :param str napalm_driver__niew: 
        :param str napalm_driver__isw: 
        :param str napalm_driver__nisw: 
        :param str napalm_driver__ie: 
        :param str napalm_driver__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str manufacturer_id__n: 
        :param str manufacturer__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_platforms_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_platforms_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_platforms_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_platforms_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str napalm_driver: 
        :param str description: 
        :param str q: 
        :param str manufacturer_id: 
        :param str manufacturer: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str napalm_driver__n: 
        :param str napalm_driver__ic: 
        :param str napalm_driver__nic: 
        :param str napalm_driver__iew: 
        :param str napalm_driver__niew: 
        :param str napalm_driver__isw: 
        :param str napalm_driver__nisw: 
        :param str napalm_driver__ie: 
        :param str napalm_driver__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str manufacturer_id__n: 
        :param str manufacturer__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'napalm_driver', 'description', 'q', 'manufacturer_id', 'manufacturer', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'napalm_driver__n', 'napalm_driver__ic', 'napalm_driver__nic', 'napalm_driver__iew', 'napalm_driver__niew', 'napalm_driver__isw', 'napalm_driver__nisw', 'napalm_driver__ie', 'napalm_driver__nie', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'manufacturer_id__n', 'manufacturer__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_platforms_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'napalm_driver' in params:
            query_params.append(('napalm_driver', params['napalm_driver']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'manufacturer_id' in params:
            query_params.append(('manufacturer_id', params['manufacturer_id']))  # noqa: E501
        if 'manufacturer' in params:
            query_params.append(('manufacturer', params['manufacturer']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'napalm_driver__n' in params:
            query_params.append(('napalm_driver__n', params['napalm_driver__n']))  # noqa: E501
        if 'napalm_driver__ic' in params:
            query_params.append(('napalm_driver__ic', params['napalm_driver__ic']))  # noqa: E501
        if 'napalm_driver__nic' in params:
            query_params.append(('napalm_driver__nic', params['napalm_driver__nic']))  # noqa: E501
        if 'napalm_driver__iew' in params:
            query_params.append(('napalm_driver__iew', params['napalm_driver__iew']))  # noqa: E501
        if 'napalm_driver__niew' in params:
            query_params.append(('napalm_driver__niew', params['napalm_driver__niew']))  # noqa: E501
        if 'napalm_driver__isw' in params:
            query_params.append(('napalm_driver__isw', params['napalm_driver__isw']))  # noqa: E501
        if 'napalm_driver__nisw' in params:
            query_params.append(('napalm_driver__nisw', params['napalm_driver__nisw']))  # noqa: E501
        if 'napalm_driver__ie' in params:
            query_params.append(('napalm_driver__ie', params['napalm_driver__ie']))  # noqa: E501
        if 'napalm_driver__nie' in params:
            query_params.append(('napalm_driver__nie', params['napalm_driver__nie']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'manufacturer_id__n' in params:
            query_params.append(('manufacturer_id__n', params['manufacturer_id__n']))  # noqa: E501
        if 'manufacturer__n' in params:
            query_params.append(('manufacturer__n', params['manufacturer__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/platforms/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_platforms_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_platforms_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this platform. (required)
        :param WritablePlatform data: (required)
        :return: Platform
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_platforms_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_platforms_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_platforms_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_platforms_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this platform. (required)
        :param WritablePlatform data: (required)
        :return: Platform
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_platforms_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_platforms_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_platforms_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/platforms/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Platform',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_platforms_read(self, id, **kwargs):  # noqa: E501
        """dcim_platforms_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this platform. (required)
        :return: Platform
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_platforms_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_platforms_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_platforms_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_platforms_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this platform. (required)
        :return: Platform
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_platforms_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_platforms_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/platforms/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Platform',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_platforms_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_platforms_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this platform. (required)
        :param WritablePlatform data: (required)
        :return: Platform
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_platforms_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_platforms_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_platforms_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_platforms_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_platforms_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this platform. (required)
        :param WritablePlatform data: (required)
        :return: Platform
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_platforms_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_platforms_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_platforms_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/platforms/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Platform',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_connections_list(self, **kwargs):  # noqa: E501
        """dcim_power_connections_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_connections_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 
        :param str connection_status: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str connection_status__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_connections_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_connections_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_power_connections_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_power_connections_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_connections_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 
        :param str connection_status: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str connection_status__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'connection_status', 'site', 'device_id', 'device', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'connection_status__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_connections_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'connection_status' in params:
            query_params.append(('connection_status', params['connection_status']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'connection_status__n' in params:
            query_params.append(('connection_status__n', params['connection_status__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-connections/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_feeds_create(self, data, **kwargs):  # noqa: E501
        """dcim_power_feeds_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerFeed data: (required)
        :return: PowerFeed
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_feeds_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_feeds_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_power_feeds_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_power_feeds_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerFeed data: (required)
        :return: PowerFeed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_feeds_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_feeds_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-feeds/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerFeed',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_feeds_delete(self, id, **kwargs):  # noqa: E501
        """dcim_power_feeds_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power feed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_feeds_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_feeds_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_feeds_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_feeds_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power feed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_feeds_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_feeds_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-feeds/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_feeds_list(self, **kwargs):  # noqa: E501
        """dcim_power_feeds_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str status: 
        :param str type: 
        :param str supply: 
        :param str phase: 
        :param str voltage: 
        :param str amperage: 
        :param str max_utilization: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str power_panel_id: 
        :param str rack_id: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str status__n: 
        :param str type__n: 
        :param str supply__n: 
        :param str phase__n: 
        :param str voltage__n: 
        :param str voltage__lte: 
        :param str voltage__lt: 
        :param str voltage__gte: 
        :param str voltage__gt: 
        :param str amperage__n: 
        :param str amperage__lte: 
        :param str amperage__lt: 
        :param str amperage__gte: 
        :param str amperage__gt: 
        :param str max_utilization__n: 
        :param str max_utilization__lte: 
        :param str max_utilization__lt: 
        :param str max_utilization__gte: 
        :param str max_utilization__gt: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str power_panel_id__n: 
        :param str rack_id__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_feeds_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_feeds_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_power_feeds_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_power_feeds_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str status: 
        :param str type: 
        :param str supply: 
        :param str phase: 
        :param str voltage: 
        :param str amperage: 
        :param str max_utilization: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str power_panel_id: 
        :param str rack_id: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str status__n: 
        :param str type__n: 
        :param str supply__n: 
        :param str phase__n: 
        :param str voltage__n: 
        :param str voltage__lte: 
        :param str voltage__lt: 
        :param str voltage__gte: 
        :param str voltage__gt: 
        :param str amperage__n: 
        :param str amperage__lte: 
        :param str amperage__lt: 
        :param str amperage__gte: 
        :param str amperage__gt: 
        :param str max_utilization__n: 
        :param str max_utilization__lte: 
        :param str max_utilization__lt: 
        :param str max_utilization__gte: 
        :param str max_utilization__gt: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str power_panel_id__n: 
        :param str rack_id__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'status', 'type', 'supply', 'phase', 'voltage', 'amperage', 'max_utilization', 'created', 'created__gte', 'created__lte', 'last_updated', 'last_updated__gte', 'last_updated__lte', 'q', 'region_id', 'region', 'site_id', 'site', 'power_panel_id', 'rack_id', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'status__n', 'type__n', 'supply__n', 'phase__n', 'voltage__n', 'voltage__lte', 'voltage__lt', 'voltage__gte', 'voltage__gt', 'amperage__n', 'amperage__lte', 'amperage__lt', 'amperage__gte', 'amperage__gt', 'max_utilization__n', 'max_utilization__lte', 'max_utilization__lt', 'max_utilization__gte', 'max_utilization__gt', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'power_panel_id__n', 'rack_id__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_feeds_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'supply' in params:
            query_params.append(('supply', params['supply']))  # noqa: E501
        if 'phase' in params:
            query_params.append(('phase', params['phase']))  # noqa: E501
        if 'voltage' in params:
            query_params.append(('voltage', params['voltage']))  # noqa: E501
        if 'amperage' in params:
            query_params.append(('amperage', params['amperage']))  # noqa: E501
        if 'max_utilization' in params:
            query_params.append(('max_utilization', params['max_utilization']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('created__gte', params['created__gte']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('created__lte', params['created__lte']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('last_updated', params['last_updated']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'power_panel_id' in params:
            query_params.append(('power_panel_id', params['power_panel_id']))  # noqa: E501
        if 'rack_id' in params:
            query_params.append(('rack_id', params['rack_id']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'status__n' in params:
            query_params.append(('status__n', params['status__n']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'supply__n' in params:
            query_params.append(('supply__n', params['supply__n']))  # noqa: E501
        if 'phase__n' in params:
            query_params.append(('phase__n', params['phase__n']))  # noqa: E501
        if 'voltage__n' in params:
            query_params.append(('voltage__n', params['voltage__n']))  # noqa: E501
        if 'voltage__lte' in params:
            query_params.append(('voltage__lte', params['voltage__lte']))  # noqa: E501
        if 'voltage__lt' in params:
            query_params.append(('voltage__lt', params['voltage__lt']))  # noqa: E501
        if 'voltage__gte' in params:
            query_params.append(('voltage__gte', params['voltage__gte']))  # noqa: E501
        if 'voltage__gt' in params:
            query_params.append(('voltage__gt', params['voltage__gt']))  # noqa: E501
        if 'amperage__n' in params:
            query_params.append(('amperage__n', params['amperage__n']))  # noqa: E501
        if 'amperage__lte' in params:
            query_params.append(('amperage__lte', params['amperage__lte']))  # noqa: E501
        if 'amperage__lt' in params:
            query_params.append(('amperage__lt', params['amperage__lt']))  # noqa: E501
        if 'amperage__gte' in params:
            query_params.append(('amperage__gte', params['amperage__gte']))  # noqa: E501
        if 'amperage__gt' in params:
            query_params.append(('amperage__gt', params['amperage__gt']))  # noqa: E501
        if 'max_utilization__n' in params:
            query_params.append(('max_utilization__n', params['max_utilization__n']))  # noqa: E501
        if 'max_utilization__lte' in params:
            query_params.append(('max_utilization__lte', params['max_utilization__lte']))  # noqa: E501
        if 'max_utilization__lt' in params:
            query_params.append(('max_utilization__lt', params['max_utilization__lt']))  # noqa: E501
        if 'max_utilization__gte' in params:
            query_params.append(('max_utilization__gte', params['max_utilization__gte']))  # noqa: E501
        if 'max_utilization__gt' in params:
            query_params.append(('max_utilization__gt', params['max_utilization__gt']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'power_panel_id__n' in params:
            query_params.append(('power_panel_id__n', params['power_panel_id__n']))  # noqa: E501
        if 'rack_id__n' in params:
            query_params.append(('rack_id__n', params['rack_id__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-feeds/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_feeds_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_feeds_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power feed. (required)
        :param WritablePowerFeed data: (required)
        :return: PowerFeed
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_feeds_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_feeds_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_feeds_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_feeds_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power feed. (required)
        :param WritablePowerFeed data: (required)
        :return: PowerFeed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_feeds_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_feeds_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_feeds_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-feeds/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerFeed',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_feeds_read(self, id, **kwargs):  # noqa: E501
        """dcim_power_feeds_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power feed. (required)
        :return: PowerFeed
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_feeds_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_feeds_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_feeds_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_feeds_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power feed. (required)
        :return: PowerFeed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_feeds_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_feeds_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-feeds/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerFeed',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_feeds_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_feeds_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power feed. (required)
        :param WritablePowerFeed data: (required)
        :return: PowerFeed
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_feeds_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_feeds_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_feeds_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_feeds_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_feeds_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power feed. (required)
        :param WritablePowerFeed data: (required)
        :return: PowerFeed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_feeds_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_feeds_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_feeds_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-feeds/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerFeed',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlet_templates_create(self, data, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerOutletTemplate data: (required)
        :return: PowerOutletTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlet_templates_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlet_templates_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlet_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerOutletTemplate data: (required)
        :return: PowerOutletTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlet_templates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_outlet_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlet-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutletTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlet_templates_delete(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlet_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlet_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlet_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlet_templates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlet_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlet-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlet_templates_list(self, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str feed_leg: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str feed_leg__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlet_templates_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlet_templates_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_power_outlet_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str feed_leg: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str feed_leg__n: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'feed_leg', 'q', 'devicetype_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'feed_leg__n', 'devicetype_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlet_templates_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'feed_leg' in params:
            query_params.append(('feed_leg', params['feed_leg']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'devicetype_id' in params:
            query_params.append(('devicetype_id', params['devicetype_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'feed_leg__n' in params:
            query_params.append(('feed_leg__n', params['feed_leg__n']))  # noqa: E501
        if 'devicetype_id__n' in params:
            query_params.append(('devicetype_id__n', params['devicetype_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlet-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlet_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet template. (required)
        :param WritablePowerOutletTemplate data: (required)
        :return: PowerOutletTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlet_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlet_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlet_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet template. (required)
        :param WritablePowerOutletTemplate data: (required)
        :return: PowerOutletTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlet_templates_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlet_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_outlet_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlet-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutletTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlet_templates_read(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet template. (required)
        :return: PowerOutletTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlet_templates_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlet_templates_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlet_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet template. (required)
        :return: PowerOutletTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlet_templates_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlet_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlet-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutletTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlet_templates_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet template. (required)
        :param WritablePowerOutletTemplate data: (required)
        :return: PowerOutletTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlet_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlet_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlet_templates_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_outlet_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlet_templates_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet template. (required)
        :param WritablePowerOutletTemplate data: (required)
        :return: PowerOutletTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlet_templates_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlet_templates_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_outlet_templates_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlet-templates/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutletTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlets_create(self, data, **kwargs):  # noqa: E501
        """dcim_power_outlets_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerOutlet data: (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlets_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlets_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlets_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_power_outlets_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerOutlet data: (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlets_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_outlets_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlets/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutlet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlets_delete(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlets_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlets_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlets_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlets_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlets_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlets_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlets_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlets/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlets_list(self, **kwargs):  # noqa: E501
        """dcim_power_outlets_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str feed_leg: 
        :param str description: 
        :param str connection_status: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str type: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str feed_leg__n: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str connection_status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str type__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlets_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlets_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_power_outlets_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_power_outlets_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str feed_leg: 
        :param str description: 
        :param str connection_status: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str type: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str feed_leg__n: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str connection_status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str type__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'feed_leg', 'description', 'connection_status', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'type', 'cabled', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'feed_leg__n', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'connection_status__n', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'device_id__n', 'device__n', 'tag__n', 'type__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlets_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'feed_leg' in params:
            query_params.append(('feed_leg', params['feed_leg']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'connection_status' in params:
            query_params.append(('connection_status', params['connection_status']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'cabled' in params:
            query_params.append(('cabled', params['cabled']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'feed_leg__n' in params:
            query_params.append(('feed_leg__n', params['feed_leg__n']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'connection_status__n' in params:
            query_params.append(('connection_status__n', params['connection_status__n']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'device_id__n' in params:
            query_params.append(('device_id__n', params['device_id__n']))  # noqa: E501
        if 'device__n' in params:
            query_params.append(('device__n', params['device__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlets/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlets_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_outlets_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :param WritablePowerOutlet data: (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlets_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlets_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlets_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_outlets_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :param WritablePowerOutlet data: (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlets_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlets_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_outlets_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlets/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutlet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlets_read(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlets_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlets_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlets_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlets_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlets_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlets_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlets_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlets/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutlet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlets_trace(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlets_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_trace(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlets_trace_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlets_trace_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlets_trace_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_outlets_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_trace_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlets_trace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlets_trace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlets/{id}/trace/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutlet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_outlets_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_outlets_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :param WritablePowerOutlet data: (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_outlets_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_outlets_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_outlets_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_outlets_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_outlets_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power outlet. (required)
        :param WritablePowerOutlet data: (required)
        :return: PowerOutlet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_outlets_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_outlets_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_outlets_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-outlets/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerOutlet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_panels_create(self, data, **kwargs):  # noqa: E501
        """dcim_power_panels_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerPanel data: (required)
        :return: PowerPanel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_panels_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_panels_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_power_panels_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_power_panels_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerPanel data: (required)
        :return: PowerPanel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_panels_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_panels_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-panels/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPanel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_panels_delete(self, id, **kwargs):  # noqa: E501
        """dcim_power_panels_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power panel. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_panels_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_panels_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_panels_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_panels_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power panel. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_panels_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_panels_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-panels/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_panels_list(self, **kwargs):  # noqa: E501
        """dcim_power_panels_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str rack_group_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str rack_group_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_panels_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_panels_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_power_panels_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_power_panels_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str rack_group_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str rack_group_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'q', 'region_id', 'region', 'site_id', 'site', 'rack_group_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'rack_group_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_panels_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'rack_group_id' in params:
            query_params.append(('rack_group_id', params['rack_group_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'rack_group_id__n' in params:
            query_params.append(('rack_group_id__n', params['rack_group_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-panels/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20026',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_panels_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_panels_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power panel. (required)
        :param WritablePowerPanel data: (required)
        :return: PowerPanel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_panels_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_panels_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_panels_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_panels_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power panel. (required)
        :param WritablePowerPanel data: (required)
        :return: PowerPanel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_panels_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_panels_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_panels_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-panels/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPanel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_panels_read(self, id, **kwargs):  # noqa: E501
        """dcim_power_panels_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power panel. (required)
        :return: PowerPanel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_panels_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_panels_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_panels_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_panels_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power panel. (required)
        :return: PowerPanel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_panels_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_panels_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-panels/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPanel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_panels_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_panels_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power panel. (required)
        :param WritablePowerPanel data: (required)
        :return: PowerPanel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_panels_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_panels_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_panels_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_panels_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_panels_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power panel. (required)
        :param WritablePowerPanel data: (required)
        :return: PowerPanel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_panels_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_panels_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_panels_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-panels/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPanel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_port_templates_create(self, data, **kwargs):  # noqa: E501
        """dcim_power_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerPortTemplate data: (required)
        :return: PowerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_power_port_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_power_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerPortTemplate data: (required)
        :return: PowerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_port_templates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_port_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-port-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_port_templates_delete(self, id, **kwargs):  # noqa: E501
        """dcim_power_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_port_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_port_templates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_port_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-port-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_port_templates_list(self, **kwargs):  # noqa: E501
        """dcim_power_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str maximum_draw: 
        :param str allocated_draw: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str maximum_draw__n: 
        :param str maximum_draw__lte: 
        :param str maximum_draw__lt: 
        :param str maximum_draw__gte: 
        :param str maximum_draw__gt: 
        :param str allocated_draw__n: 
        :param str allocated_draw__lte: 
        :param str allocated_draw__lt: 
        :param str allocated_draw__gte: 
        :param str allocated_draw__gt: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_port_templates_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_port_templates_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_power_port_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_power_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str maximum_draw: 
        :param str allocated_draw: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str maximum_draw__n: 
        :param str maximum_draw__lte: 
        :param str maximum_draw__lt: 
        :param str maximum_draw__gte: 
        :param str maximum_draw__gt: 
        :param str allocated_draw__n: 
        :param str allocated_draw__lte: 
        :param str allocated_draw__lt: 
        :param str allocated_draw__gte: 
        :param str allocated_draw__gt: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'maximum_draw', 'allocated_draw', 'q', 'devicetype_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'maximum_draw__n', 'maximum_draw__lte', 'maximum_draw__lt', 'maximum_draw__gte', 'maximum_draw__gt', 'allocated_draw__n', 'allocated_draw__lte', 'allocated_draw__lt', 'allocated_draw__gte', 'allocated_draw__gt', 'devicetype_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_port_templates_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'maximum_draw' in params:
            query_params.append(('maximum_draw', params['maximum_draw']))  # noqa: E501
        if 'allocated_draw' in params:
            query_params.append(('allocated_draw', params['allocated_draw']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'devicetype_id' in params:
            query_params.append(('devicetype_id', params['devicetype_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'maximum_draw__n' in params:
            query_params.append(('maximum_draw__n', params['maximum_draw__n']))  # noqa: E501
        if 'maximum_draw__lte' in params:
            query_params.append(('maximum_draw__lte', params['maximum_draw__lte']))  # noqa: E501
        if 'maximum_draw__lt' in params:
            query_params.append(('maximum_draw__lt', params['maximum_draw__lt']))  # noqa: E501
        if 'maximum_draw__gte' in params:
            query_params.append(('maximum_draw__gte', params['maximum_draw__gte']))  # noqa: E501
        if 'maximum_draw__gt' in params:
            query_params.append(('maximum_draw__gt', params['maximum_draw__gt']))  # noqa: E501
        if 'allocated_draw__n' in params:
            query_params.append(('allocated_draw__n', params['allocated_draw__n']))  # noqa: E501
        if 'allocated_draw__lte' in params:
            query_params.append(('allocated_draw__lte', params['allocated_draw__lte']))  # noqa: E501
        if 'allocated_draw__lt' in params:
            query_params.append(('allocated_draw__lt', params['allocated_draw__lt']))  # noqa: E501
        if 'allocated_draw__gte' in params:
            query_params.append(('allocated_draw__gte', params['allocated_draw__gte']))  # noqa: E501
        if 'allocated_draw__gt' in params:
            query_params.append(('allocated_draw__gt', params['allocated_draw__gt']))  # noqa: E501
        if 'devicetype_id__n' in params:
            query_params.append(('devicetype_id__n', params['devicetype_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-port-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_port_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port template. (required)
        :param WritablePowerPortTemplate data: (required)
        :return: PowerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_port_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port template. (required)
        :param WritablePowerPortTemplate data: (required)
        :return: PowerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_port_templates_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_port_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_port_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-port-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_port_templates_read(self, id, **kwargs):  # noqa: E501
        """dcim_power_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port template. (required)
        :return: PowerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_port_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port template. (required)
        :return: PowerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_port_templates_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_port_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-port-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_port_templates_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port template. (required)
        :param WritablePowerPortTemplate data: (required)
        :return: PowerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_port_templates_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_port_templates_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port template. (required)
        :param WritablePowerPortTemplate data: (required)
        :return: PowerPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_port_templates_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_port_templates_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_port_templates_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-port-templates/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_ports_create(self, data, **kwargs):  # noqa: E501
        """dcim_power_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerPort data: (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_ports_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_ports_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_power_ports_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_power_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritablePowerPort data: (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_ports_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_ports_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-ports/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_ports_delete(self, id, **kwargs):  # noqa: E501
        """dcim_power_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_ports_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_ports_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_ports_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-ports/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_ports_list(self, **kwargs):  # noqa: E501
        """dcim_power_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str maximum_draw: 
        :param str allocated_draw: 
        :param str description: 
        :param str connection_status: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str type: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str maximum_draw__n: 
        :param str maximum_draw__lte: 
        :param str maximum_draw__lt: 
        :param str maximum_draw__gte: 
        :param str maximum_draw__gt: 
        :param str allocated_draw__n: 
        :param str allocated_draw__lte: 
        :param str allocated_draw__lt: 
        :param str allocated_draw__gte: 
        :param str allocated_draw__gt: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str connection_status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str type__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_ports_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_ports_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_power_ports_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_power_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str maximum_draw: 
        :param str allocated_draw: 
        :param str description: 
        :param str connection_status: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str type: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str maximum_draw__n: 
        :param str maximum_draw__lte: 
        :param str maximum_draw__lt: 
        :param str maximum_draw__gte: 
        :param str maximum_draw__gt: 
        :param str allocated_draw__n: 
        :param str allocated_draw__lte: 
        :param str allocated_draw__lt: 
        :param str allocated_draw__gte: 
        :param str allocated_draw__gt: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str connection_status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param str type__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'maximum_draw', 'allocated_draw', 'description', 'connection_status', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'type', 'cabled', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'maximum_draw__n', 'maximum_draw__lte', 'maximum_draw__lt', 'maximum_draw__gte', 'maximum_draw__gt', 'allocated_draw__n', 'allocated_draw__lte', 'allocated_draw__lt', 'allocated_draw__gte', 'allocated_draw__gt', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'connection_status__n', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'device_id__n', 'device__n', 'tag__n', 'type__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_ports_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'maximum_draw' in params:
            query_params.append(('maximum_draw', params['maximum_draw']))  # noqa: E501
        if 'allocated_draw' in params:
            query_params.append(('allocated_draw', params['allocated_draw']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'connection_status' in params:
            query_params.append(('connection_status', params['connection_status']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'cabled' in params:
            query_params.append(('cabled', params['cabled']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'maximum_draw__n' in params:
            query_params.append(('maximum_draw__n', params['maximum_draw__n']))  # noqa: E501
        if 'maximum_draw__lte' in params:
            query_params.append(('maximum_draw__lte', params['maximum_draw__lte']))  # noqa: E501
        if 'maximum_draw__lt' in params:
            query_params.append(('maximum_draw__lt', params['maximum_draw__lt']))  # noqa: E501
        if 'maximum_draw__gte' in params:
            query_params.append(('maximum_draw__gte', params['maximum_draw__gte']))  # noqa: E501
        if 'maximum_draw__gt' in params:
            query_params.append(('maximum_draw__gt', params['maximum_draw__gt']))  # noqa: E501
        if 'allocated_draw__n' in params:
            query_params.append(('allocated_draw__n', params['allocated_draw__n']))  # noqa: E501
        if 'allocated_draw__lte' in params:
            query_params.append(('allocated_draw__lte', params['allocated_draw__lte']))  # noqa: E501
        if 'allocated_draw__lt' in params:
            query_params.append(('allocated_draw__lt', params['allocated_draw__lt']))  # noqa: E501
        if 'allocated_draw__gte' in params:
            query_params.append(('allocated_draw__gte', params['allocated_draw__gte']))  # noqa: E501
        if 'allocated_draw__gt' in params:
            query_params.append(('allocated_draw__gt', params['allocated_draw__gt']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'connection_status__n' in params:
            query_params.append(('connection_status__n', params['connection_status__n']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'device_id__n' in params:
            query_params.append(('device_id__n', params['device_id__n']))  # noqa: E501
        if 'device__n' in params:
            query_params.append(('device__n', params['device__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-ports/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_ports_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :param WritablePowerPort data: (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_ports_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :param WritablePowerPort data: (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_ports_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_ports_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_ports_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-ports/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_ports_read(self, id, **kwargs):  # noqa: E501
        """dcim_power_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_ports_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_ports_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_ports_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_ports_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_ports_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-ports/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_ports_trace(self, id, **kwargs):  # noqa: E501
        """dcim_power_ports_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_trace(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_ports_trace_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_ports_trace_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_power_ports_trace_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_power_ports_trace  # noqa: E501

        Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_trace_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_ports_trace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_ports_trace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-ports/{id}/trace/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_power_ports_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :param WritablePowerPort data: (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_power_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_power_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_power_ports_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_power_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_power_ports_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this power port. (required)
        :param WritablePowerPort data: (required)
        :return: PowerPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_power_ports_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_power_ports_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_power_ports_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/power-ports/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PowerPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_groups_create(self, data, **kwargs):  # noqa: E501
        """dcim_rack_groups_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRackGroup data: (required)
        :return: RackGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_groups_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_groups_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_groups_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_rack_groups_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRackGroup data: (required)
        :return: RackGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_groups_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_groups_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-groups/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_groups_delete(self, id, **kwargs):  # noqa: E501
        """dcim_rack_groups_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack group. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_groups_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_groups_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rack_groups_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rack_groups_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack group. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_groups_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_groups_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-groups/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_groups_list(self, **kwargs):  # noqa: E501
        """dcim_rack_groups_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str parent_id: 
        :param str parent: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str parent_id__n: 
        :param str parent__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_groups_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_groups_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_rack_groups_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_rack_groups_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str parent_id: 
        :param str parent: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str parent_id__n: 
        :param str parent__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'description', 'q', 'region_id', 'region', 'site_id', 'site', 'parent_id', 'parent', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'parent_id__n', 'parent__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_groups_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'parent_id' in params:
            query_params.append(('parent_id', params['parent_id']))  # noqa: E501
        if 'parent' in params:
            query_params.append(('parent', params['parent']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'parent_id__n' in params:
            query_params.append(('parent_id__n', params['parent_id__n']))  # noqa: E501
        if 'parent__n' in params:
            query_params.append(('parent__n', params['parent__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-groups/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20028',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_groups_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_groups_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack group. (required)
        :param WritableRackGroup data: (required)
        :return: RackGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_groups_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_groups_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_groups_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_groups_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack group. (required)
        :param WritableRackGroup data: (required)
        :return: RackGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_groups_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_groups_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_groups_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-groups/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_groups_read(self, id, **kwargs):  # noqa: E501
        """dcim_rack_groups_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack group. (required)
        :return: RackGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_groups_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_groups_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rack_groups_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rack_groups_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack group. (required)
        :return: RackGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_groups_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_groups_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-groups/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_groups_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_groups_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack group. (required)
        :param WritableRackGroup data: (required)
        :return: RackGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_groups_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_groups_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_groups_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_groups_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_groups_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack group. (required)
        :param WritableRackGroup data: (required)
        :return: RackGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_groups_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_groups_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_groups_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-groups/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_reservations_create(self, data, **kwargs):  # noqa: E501
        """dcim_rack_reservations_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRackReservation data: (required)
        :return: RackReservation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_reservations_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_reservations_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_reservations_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_rack_reservations_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRackReservation data: (required)
        :return: RackReservation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_reservations_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_reservations_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-reservations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackReservation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_reservations_delete(self, id, **kwargs):  # noqa: E501
        """dcim_rack_reservations_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack reservation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_reservations_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_reservations_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rack_reservations_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rack_reservations_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack reservation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_reservations_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_reservations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-reservations/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_reservations_list(self, **kwargs):  # noqa: E501
        """dcim_rack_reservations_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str created: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str q: 
        :param str rack_id: 
        :param str site_id: 
        :param str site: 
        :param str group_id: 
        :param str group: 
        :param str user_id: 
        :param str user: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str created__n: 
        :param str created__lte: 
        :param str created__lt: 
        :param str created__gte: 
        :param str created__gt: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str rack_id__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str group_id__n: 
        :param str group__n: 
        :param str user_id__n: 
        :param str user__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_reservations_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_reservations_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_rack_reservations_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_rack_reservations_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str created: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str q: 
        :param str rack_id: 
        :param str site_id: 
        :param str site: 
        :param str group_id: 
        :param str group: 
        :param str user_id: 
        :param str user: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str created__n: 
        :param str created__lte: 
        :param str created__lt: 
        :param str created__gte: 
        :param str created__gt: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str rack_id__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str group_id__n: 
        :param str group__n: 
        :param str user_id__n: 
        :param str user__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'created', 'tenant_group_id', 'tenant_group', 'tenant_id', 'tenant', 'q', 'rack_id', 'site_id', 'site', 'group_id', 'group', 'user_id', 'user', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'created__n', 'created__lte', 'created__lt', 'created__gte', 'created__gt', 'tenant_group_id__n', 'tenant_group__n', 'tenant_id__n', 'tenant__n', 'rack_id__n', 'site_id__n', 'site__n', 'group_id__n', 'group__n', 'user_id__n', 'user__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_reservations_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'tenant_group_id' in params:
            query_params.append(('tenant_group_id', params['tenant_group_id']))  # noqa: E501
        if 'tenant_group' in params:
            query_params.append(('tenant_group', params['tenant_group']))  # noqa: E501
        if 'tenant_id' in params:
            query_params.append(('tenant_id', params['tenant_id']))  # noqa: E501
        if 'tenant' in params:
            query_params.append(('tenant', params['tenant']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'rack_id' in params:
            query_params.append(('rack_id', params['rack_id']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'group_id' in params:
            query_params.append(('group_id', params['group_id']))  # noqa: E501
        if 'group' in params:
            query_params.append(('group', params['group']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('user_id', params['user_id']))  # noqa: E501
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'created__n' in params:
            query_params.append(('created__n', params['created__n']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('created__lte', params['created__lte']))  # noqa: E501
        if 'created__lt' in params:
            query_params.append(('created__lt', params['created__lt']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('created__gte', params['created__gte']))  # noqa: E501
        if 'created__gt' in params:
            query_params.append(('created__gt', params['created__gt']))  # noqa: E501
        if 'tenant_group_id__n' in params:
            query_params.append(('tenant_group_id__n', params['tenant_group_id__n']))  # noqa: E501
        if 'tenant_group__n' in params:
            query_params.append(('tenant_group__n', params['tenant_group__n']))  # noqa: E501
        if 'tenant_id__n' in params:
            query_params.append(('tenant_id__n', params['tenant_id__n']))  # noqa: E501
        if 'tenant__n' in params:
            query_params.append(('tenant__n', params['tenant__n']))  # noqa: E501
        if 'rack_id__n' in params:
            query_params.append(('rack_id__n', params['rack_id__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'group_id__n' in params:
            query_params.append(('group_id__n', params['group_id__n']))  # noqa: E501
        if 'group__n' in params:
            query_params.append(('group__n', params['group__n']))  # noqa: E501
        if 'user_id__n' in params:
            query_params.append(('user_id__n', params['user_id__n']))  # noqa: E501
        if 'user__n' in params:
            query_params.append(('user__n', params['user__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-reservations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_reservations_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_reservations_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack reservation. (required)
        :param WritableRackReservation data: (required)
        :return: RackReservation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_reservations_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_reservations_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_reservations_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_reservations_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack reservation. (required)
        :param WritableRackReservation data: (required)
        :return: RackReservation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_reservations_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_reservations_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_reservations_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-reservations/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackReservation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_reservations_read(self, id, **kwargs):  # noqa: E501
        """dcim_rack_reservations_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack reservation. (required)
        :return: RackReservation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_reservations_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_reservations_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rack_reservations_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rack_reservations_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack reservation. (required)
        :return: RackReservation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_reservations_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_reservations_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-reservations/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackReservation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_reservations_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_reservations_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack reservation. (required)
        :param WritableRackReservation data: (required)
        :return: RackReservation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_reservations_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_reservations_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_reservations_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_reservations_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_reservations_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack reservation. (required)
        :param WritableRackReservation data: (required)
        :return: RackReservation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_reservations_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_reservations_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_reservations_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-reservations/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackReservation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_roles_create(self, data, **kwargs):  # noqa: E501
        """dcim_rack_roles_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RackRole data: (required)
        :return: RackRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_roles_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_roles_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_roles_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_rack_roles_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RackRole data: (required)
        :return: RackRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_roles_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_roles_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-roles/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_roles_delete(self, id, **kwargs):  # noqa: E501
        """dcim_rack_roles_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack role. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_roles_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_roles_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rack_roles_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rack_roles_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack role. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_roles_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_roles_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-roles/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_roles_list(self, **kwargs):  # noqa: E501
        """dcim_rack_roles_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str color: 
        :param str q: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str color__n: 
        :param str color__ic: 
        :param str color__nic: 
        :param str color__iew: 
        :param str color__niew: 
        :param str color__isw: 
        :param str color__nisw: 
        :param str color__ie: 
        :param str color__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_roles_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_roles_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_rack_roles_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_rack_roles_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str color: 
        :param str q: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str color__n: 
        :param str color__ic: 
        :param str color__nic: 
        :param str color__iew: 
        :param str color__niew: 
        :param str color__isw: 
        :param str color__nisw: 
        :param str color__ie: 
        :param str color__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'color', 'q', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'color__n', 'color__ic', 'color__nic', 'color__iew', 'color__niew', 'color__isw', 'color__nisw', 'color__ie', 'color__nie', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_roles_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'color' in params:
            query_params.append(('color', params['color']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'color__n' in params:
            query_params.append(('color__n', params['color__n']))  # noqa: E501
        if 'color__ic' in params:
            query_params.append(('color__ic', params['color__ic']))  # noqa: E501
        if 'color__nic' in params:
            query_params.append(('color__nic', params['color__nic']))  # noqa: E501
        if 'color__iew' in params:
            query_params.append(('color__iew', params['color__iew']))  # noqa: E501
        if 'color__niew' in params:
            query_params.append(('color__niew', params['color__niew']))  # noqa: E501
        if 'color__isw' in params:
            query_params.append(('color__isw', params['color__isw']))  # noqa: E501
        if 'color__nisw' in params:
            query_params.append(('color__nisw', params['color__nisw']))  # noqa: E501
        if 'color__ie' in params:
            query_params.append(('color__ie', params['color__ie']))  # noqa: E501
        if 'color__nie' in params:
            query_params.append(('color__nie', params['color__nie']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-roles/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_roles_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_roles_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack role. (required)
        :param RackRole data: (required)
        :return: RackRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_roles_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_roles_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_roles_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_roles_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack role. (required)
        :param RackRole data: (required)
        :return: RackRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_roles_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_roles_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_roles_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-roles/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_roles_read(self, id, **kwargs):  # noqa: E501
        """dcim_rack_roles_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack role. (required)
        :return: RackRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_roles_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_roles_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rack_roles_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rack_roles_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack role. (required)
        :return: RackRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_roles_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_roles_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-roles/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rack_roles_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_roles_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack role. (required)
        :param RackRole data: (required)
        :return: RackRole
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rack_roles_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rack_roles_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rack_roles_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rack_roles_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rack_roles_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack role. (required)
        :param RackRole data: (required)
        :return: RackRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rack_roles_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rack_roles_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rack_roles_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rack-roles/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RackRole',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_racks_create(self, data, **kwargs):  # noqa: E501
        """dcim_racks_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRack data: (required)
        :return: Rack
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_racks_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_racks_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_racks_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_racks_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRack data: (required)
        :return: Rack
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_racks_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_racks_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/racks/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Rack',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_racks_delete(self, id, **kwargs):  # noqa: E501
        """dcim_racks_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_racks_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_racks_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_racks_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_racks_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_racks_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_racks_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/racks/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_racks_elevation(self, id, **kwargs):  # noqa: E501
        """dcim_racks_elevation  # noqa: E501

        Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_elevation(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :param str q:
        :param str face:
        :param str render:
        :param int unit_width:
        :param int unit_height:
        :param int legend_width:
        :param int exclude:
        :param bool expand_devices:
        :param bool include_images:
        :return: list[RackUnit]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_racks_elevation_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_racks_elevation_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_racks_elevation_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_racks_elevation  # noqa: E501

        Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_elevation_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :param str q:
        :param str face:
        :param str render:
        :param int unit_width:
        :param int unit_height:
        :param int legend_width:
        :param int exclude:
        :param bool expand_devices:
        :param bool include_images:
        :return: list[RackUnit]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'q', 'face', 'render', 'unit_width', 'unit_height', 'legend_width', 'exclude', 'expand_devices', 'include_images']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_racks_elevation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_racks_elevation`")  # noqa: E501

        if ('q' in params and
                len(params['q']) < 1):
            raise ValueError("Invalid value for parameter `q` when calling `dcim_racks_elevation`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'face' in params:
            query_params.append(('face', params['face']))  # noqa: E501
        if 'render' in params:
            query_params.append(('render', params['render']))  # noqa: E501
        if 'unit_width' in params:
            query_params.append(('unit_width', params['unit_width']))  # noqa: E501
        if 'unit_height' in params:
            query_params.append(('unit_height', params['unit_height']))  # noqa: E501
        if 'legend_width' in params:
            query_params.append(('legend_width', params['legend_width']))  # noqa: E501
        if 'exclude' in params:
            query_params.append(('exclude', params['exclude']))  # noqa: E501
        if 'expand_devices' in params:
            query_params.append(('expand_devices', params['expand_devices']))  # noqa: E501
        if 'include_images' in params:
            query_params.append(('include_images', params['include_images']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/racks/{id}/elevation/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RackUnit]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_racks_list(self, **kwargs):  # noqa: E501
        """dcim_racks_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str facility_id: 
        :param str asset_tag: 
        :param str type: 
        :param str width: 
        :param str u_height: 
        :param str desc_units: 
        :param str outer_width: 
        :param str outer_depth: 
        :param str outer_unit: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str group_id: 
        :param str group: 
        :param str status: 
        :param str role_id: 
        :param str role: 
        :param str serial: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str facility_id__n: 
        :param str facility_id__ic: 
        :param str facility_id__nic: 
        :param str facility_id__iew: 
        :param str facility_id__niew: 
        :param str facility_id__isw: 
        :param str facility_id__nisw: 
        :param str facility_id__ie: 
        :param str facility_id__nie: 
        :param str asset_tag__n: 
        :param str asset_tag__ic: 
        :param str asset_tag__nic: 
        :param str asset_tag__iew: 
        :param str asset_tag__niew: 
        :param str asset_tag__isw: 
        :param str asset_tag__nisw: 
        :param str asset_tag__ie: 
        :param str asset_tag__nie: 
        :param str type__n: 
        :param str width__n: 
        :param str u_height__n: 
        :param str u_height__lte: 
        :param str u_height__lt: 
        :param str u_height__gte: 
        :param str u_height__gt: 
        :param str outer_width__n: 
        :param str outer_width__lte: 
        :param str outer_width__lt: 
        :param str outer_width__gte: 
        :param str outer_width__gt: 
        :param str outer_depth__n: 
        :param str outer_depth__lte: 
        :param str outer_depth__lt: 
        :param str outer_depth__gte: 
        :param str outer_depth__gt: 
        :param str outer_unit__n: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str group_id__n: 
        :param str group__n: 
        :param str status__n: 
        :param str role_id__n: 
        :param str role__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_racks_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_racks_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_racks_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_racks_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str facility_id: 
        :param str asset_tag: 
        :param str type: 
        :param str width: 
        :param str u_height: 
        :param str desc_units: 
        :param str outer_width: 
        :param str outer_depth: 
        :param str outer_unit: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str group_id: 
        :param str group: 
        :param str status: 
        :param str role_id: 
        :param str role: 
        :param str serial: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str facility_id__n: 
        :param str facility_id__ic: 
        :param str facility_id__nic: 
        :param str facility_id__iew: 
        :param str facility_id__niew: 
        :param str facility_id__isw: 
        :param str facility_id__nisw: 
        :param str facility_id__ie: 
        :param str facility_id__nie: 
        :param str asset_tag__n: 
        :param str asset_tag__ic: 
        :param str asset_tag__nic: 
        :param str asset_tag__iew: 
        :param str asset_tag__niew: 
        :param str asset_tag__isw: 
        :param str asset_tag__nisw: 
        :param str asset_tag__ie: 
        :param str asset_tag__nie: 
        :param str type__n: 
        :param str width__n: 
        :param str u_height__n: 
        :param str u_height__lte: 
        :param str u_height__lt: 
        :param str u_height__gte: 
        :param str u_height__gt: 
        :param str outer_width__n: 
        :param str outer_width__lte: 
        :param str outer_width__lt: 
        :param str outer_width__gte: 
        :param str outer_width__gt: 
        :param str outer_depth__n: 
        :param str outer_depth__lte: 
        :param str outer_depth__lt: 
        :param str outer_depth__gte: 
        :param str outer_depth__gt: 
        :param str outer_unit__n: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str group_id__n: 
        :param str group__n: 
        :param str status__n: 
        :param str role_id__n: 
        :param str role__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'facility_id', 'asset_tag', 'type', 'width', 'u_height', 'desc_units', 'outer_width', 'outer_depth', 'outer_unit', 'tenant_group_id', 'tenant_group', 'tenant_id', 'tenant', 'created', 'created__gte', 'created__lte', 'last_updated', 'last_updated__gte', 'last_updated__lte', 'q', 'region_id', 'region', 'site_id', 'site', 'group_id', 'group', 'status', 'role_id', 'role', 'serial', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'facility_id__n', 'facility_id__ic', 'facility_id__nic', 'facility_id__iew', 'facility_id__niew', 'facility_id__isw', 'facility_id__nisw', 'facility_id__ie', 'facility_id__nie', 'asset_tag__n', 'asset_tag__ic', 'asset_tag__nic', 'asset_tag__iew', 'asset_tag__niew', 'asset_tag__isw', 'asset_tag__nisw', 'asset_tag__ie', 'asset_tag__nie', 'type__n', 'width__n', 'u_height__n', 'u_height__lte', 'u_height__lt', 'u_height__gte', 'u_height__gt', 'outer_width__n', 'outer_width__lte', 'outer_width__lt', 'outer_width__gte', 'outer_width__gt', 'outer_depth__n', 'outer_depth__lte', 'outer_depth__lt', 'outer_depth__gte', 'outer_depth__gt', 'outer_unit__n', 'tenant_group_id__n', 'tenant_group__n', 'tenant_id__n', 'tenant__n', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'group_id__n', 'group__n', 'status__n', 'role_id__n', 'role__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_racks_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'facility_id' in params:
            query_params.append(('facility_id', params['facility_id']))  # noqa: E501
        if 'asset_tag' in params:
            query_params.append(('asset_tag', params['asset_tag']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'width' in params:
            query_params.append(('width', params['width']))  # noqa: E501
        if 'u_height' in params:
            query_params.append(('u_height', params['u_height']))  # noqa: E501
        if 'desc_units' in params:
            query_params.append(('desc_units', params['desc_units']))  # noqa: E501
        if 'outer_width' in params:
            query_params.append(('outer_width', params['outer_width']))  # noqa: E501
        if 'outer_depth' in params:
            query_params.append(('outer_depth', params['outer_depth']))  # noqa: E501
        if 'outer_unit' in params:
            query_params.append(('outer_unit', params['outer_unit']))  # noqa: E501
        if 'tenant_group_id' in params:
            query_params.append(('tenant_group_id', params['tenant_group_id']))  # noqa: E501
        if 'tenant_group' in params:
            query_params.append(('tenant_group', params['tenant_group']))  # noqa: E501
        if 'tenant_id' in params:
            query_params.append(('tenant_id', params['tenant_id']))  # noqa: E501
        if 'tenant' in params:
            query_params.append(('tenant', params['tenant']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('created__gte', params['created__gte']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('created__lte', params['created__lte']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('last_updated', params['last_updated']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'group_id' in params:
            query_params.append(('group_id', params['group_id']))  # noqa: E501
        if 'group' in params:
            query_params.append(('group', params['group']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'role_id' in params:
            query_params.append(('role_id', params['role_id']))  # noqa: E501
        if 'role' in params:
            query_params.append(('role', params['role']))  # noqa: E501
        if 'serial' in params:
            query_params.append(('serial', params['serial']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'facility_id__n' in params:
            query_params.append(('facility_id__n', params['facility_id__n']))  # noqa: E501
        if 'facility_id__ic' in params:
            query_params.append(('facility_id__ic', params['facility_id__ic']))  # noqa: E501
        if 'facility_id__nic' in params:
            query_params.append(('facility_id__nic', params['facility_id__nic']))  # noqa: E501
        if 'facility_id__iew' in params:
            query_params.append(('facility_id__iew', params['facility_id__iew']))  # noqa: E501
        if 'facility_id__niew' in params:
            query_params.append(('facility_id__niew', params['facility_id__niew']))  # noqa: E501
        if 'facility_id__isw' in params:
            query_params.append(('facility_id__isw', params['facility_id__isw']))  # noqa: E501
        if 'facility_id__nisw' in params:
            query_params.append(('facility_id__nisw', params['facility_id__nisw']))  # noqa: E501
        if 'facility_id__ie' in params:
            query_params.append(('facility_id__ie', params['facility_id__ie']))  # noqa: E501
        if 'facility_id__nie' in params:
            query_params.append(('facility_id__nie', params['facility_id__nie']))  # noqa: E501
        if 'asset_tag__n' in params:
            query_params.append(('asset_tag__n', params['asset_tag__n']))  # noqa: E501
        if 'asset_tag__ic' in params:
            query_params.append(('asset_tag__ic', params['asset_tag__ic']))  # noqa: E501
        if 'asset_tag__nic' in params:
            query_params.append(('asset_tag__nic', params['asset_tag__nic']))  # noqa: E501
        if 'asset_tag__iew' in params:
            query_params.append(('asset_tag__iew', params['asset_tag__iew']))  # noqa: E501
        if 'asset_tag__niew' in params:
            query_params.append(('asset_tag__niew', params['asset_tag__niew']))  # noqa: E501
        if 'asset_tag__isw' in params:
            query_params.append(('asset_tag__isw', params['asset_tag__isw']))  # noqa: E501
        if 'asset_tag__nisw' in params:
            query_params.append(('asset_tag__nisw', params['asset_tag__nisw']))  # noqa: E501
        if 'asset_tag__ie' in params:
            query_params.append(('asset_tag__ie', params['asset_tag__ie']))  # noqa: E501
        if 'asset_tag__nie' in params:
            query_params.append(('asset_tag__nie', params['asset_tag__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'width__n' in params:
            query_params.append(('width__n', params['width__n']))  # noqa: E501
        if 'u_height__n' in params:
            query_params.append(('u_height__n', params['u_height__n']))  # noqa: E501
        if 'u_height__lte' in params:
            query_params.append(('u_height__lte', params['u_height__lte']))  # noqa: E501
        if 'u_height__lt' in params:
            query_params.append(('u_height__lt', params['u_height__lt']))  # noqa: E501
        if 'u_height__gte' in params:
            query_params.append(('u_height__gte', params['u_height__gte']))  # noqa: E501
        if 'u_height__gt' in params:
            query_params.append(('u_height__gt', params['u_height__gt']))  # noqa: E501
        if 'outer_width__n' in params:
            query_params.append(('outer_width__n', params['outer_width__n']))  # noqa: E501
        if 'outer_width__lte' in params:
            query_params.append(('outer_width__lte', params['outer_width__lte']))  # noqa: E501
        if 'outer_width__lt' in params:
            query_params.append(('outer_width__lt', params['outer_width__lt']))  # noqa: E501
        if 'outer_width__gte' in params:
            query_params.append(('outer_width__gte', params['outer_width__gte']))  # noqa: E501
        if 'outer_width__gt' in params:
            query_params.append(('outer_width__gt', params['outer_width__gt']))  # noqa: E501
        if 'outer_depth__n' in params:
            query_params.append(('outer_depth__n', params['outer_depth__n']))  # noqa: E501
        if 'outer_depth__lte' in params:
            query_params.append(('outer_depth__lte', params['outer_depth__lte']))  # noqa: E501
        if 'outer_depth__lt' in params:
            query_params.append(('outer_depth__lt', params['outer_depth__lt']))  # noqa: E501
        if 'outer_depth__gte' in params:
            query_params.append(('outer_depth__gte', params['outer_depth__gte']))  # noqa: E501
        if 'outer_depth__gt' in params:
            query_params.append(('outer_depth__gt', params['outer_depth__gt']))  # noqa: E501
        if 'outer_unit__n' in params:
            query_params.append(('outer_unit__n', params['outer_unit__n']))  # noqa: E501
        if 'tenant_group_id__n' in params:
            query_params.append(('tenant_group_id__n', params['tenant_group_id__n']))  # noqa: E501
        if 'tenant_group__n' in params:
            query_params.append(('tenant_group__n', params['tenant_group__n']))  # noqa: E501
        if 'tenant_id__n' in params:
            query_params.append(('tenant_id__n', params['tenant_id__n']))  # noqa: E501
        if 'tenant__n' in params:
            query_params.append(('tenant__n', params['tenant__n']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'group_id__n' in params:
            query_params.append(('group_id__n', params['group_id__n']))  # noqa: E501
        if 'group__n' in params:
            query_params.append(('group__n', params['group__n']))  # noqa: E501
        if 'status__n' in params:
            query_params.append(('status__n', params['status__n']))  # noqa: E501
        if 'role_id__n' in params:
            query_params.append(('role_id__n', params['role_id__n']))  # noqa: E501
        if 'role__n' in params:
            query_params.append(('role__n', params['role__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/racks/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_racks_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_racks_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :param WritableRack data: (required)
        :return: Rack
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_racks_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_racks_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_racks_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_racks_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :param WritableRack data: (required)
        :return: Rack
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_racks_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_racks_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_racks_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/racks/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Rack',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_racks_read(self, id, **kwargs):  # noqa: E501
        """dcim_racks_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :return: Rack
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_racks_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_racks_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_racks_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_racks_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :return: Rack
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_racks_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_racks_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/racks/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Rack',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_racks_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_racks_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :param WritableRack data: (required)
        :return: Rack
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_racks_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_racks_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_racks_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_racks_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_racks_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rack. (required)
        :param WritableRack data: (required)
        :return: Rack
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_racks_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_racks_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_racks_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/racks/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Rack',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_port_templates_create(self, data, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRearPortTemplate data: (required)
        :return: RearPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_port_templates_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_rear_port_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRearPortTemplate data: (required)
        :return: RearPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_port_templates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rear_port_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-port-templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RearPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_port_templates_delete(self, id, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_port_templates_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rear_port_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port template. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_port_templates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rear_port_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-port-templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_port_templates_list(self, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str positions: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str positions__n: 
        :param str positions__lte: 
        :param str positions__lt: 
        :param str positions__gte: 
        :param str positions__gt: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_port_templates_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_port_templates_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_rear_port_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str positions: 
        :param str q: 
        :param str devicetype_id: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str positions__n: 
        :param str positions__lte: 
        :param str positions__lt: 
        :param str positions__gte: 
        :param str positions__gt: 
        :param str devicetype_id__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'positions', 'q', 'devicetype_id', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'positions__n', 'positions__lte', 'positions__lt', 'positions__gte', 'positions__gt', 'devicetype_id__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_port_templates_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'positions' in params:
            query_params.append(('positions', params['positions']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'devicetype_id' in params:
            query_params.append(('devicetype_id', params['devicetype_id']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'positions__n' in params:
            query_params.append(('positions__n', params['positions__n']))  # noqa: E501
        if 'positions__lte' in params:
            query_params.append(('positions__lte', params['positions__lte']))  # noqa: E501
        if 'positions__lt' in params:
            query_params.append(('positions__lt', params['positions__lt']))  # noqa: E501
        if 'positions__gte' in params:
            query_params.append(('positions__gte', params['positions__gte']))  # noqa: E501
        if 'positions__gt' in params:
            query_params.append(('positions__gt', params['positions__gt']))  # noqa: E501
        if 'devicetype_id__n' in params:
            query_params.append(('devicetype_id__n', params['devicetype_id__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-port-templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_port_templates_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port template. (required)
        :param WritableRearPortTemplate data: (required)
        :return: RearPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_port_templates_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rear_port_templates_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port template. (required)
        :param WritableRearPortTemplate data: (required)
        :return: RearPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_port_templates_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rear_port_templates_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rear_port_templates_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-port-templates/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RearPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_port_templates_read(self, id, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port template. (required)
        :return: RearPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_port_templates_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rear_port_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port template. (required)
        :return: RearPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_port_templates_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rear_port_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-port-templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RearPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_port_templates_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port template. (required)
        :param WritableRearPortTemplate data: (required)
        :return: RearPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_port_templates_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rear_port_templates_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rear_port_templates_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_port_templates_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port template. (required)
        :param WritableRearPortTemplate data: (required)
        :return: RearPortTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_port_templates_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rear_port_templates_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rear_port_templates_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-port-templates/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RearPortTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_ports_create(self, data, **kwargs):  # noqa: E501
        """dcim_rear_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRearPort data: (required)
        :return: RearPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_ports_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_ports_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_rear_ports_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_rear_ports_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRearPort data: (required)
        :return: RearPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_ports_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rear_ports_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-ports/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RearPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_ports_delete(self, id, **kwargs):  # noqa: E501
        """dcim_rear_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_ports_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rear_ports_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rear_ports_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_ports_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rear_ports_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-ports/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_ports_list(self, **kwargs):  # noqa: E501
        """dcim_rear_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str positions: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str positions__n: 
        :param str positions__lte: 
        :param str positions__lt: 
        :param str positions__gte: 
        :param str positions__gt: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_ports_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_ports_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_rear_ports_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_rear_ports_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str type: 
        :param str positions: 
        :param str description: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str device_id: 
        :param str device: 
        :param str tag: 
        :param str cabled: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str type__n: 
        :param str positions__n: 
        :param str positions__lte: 
        :param str positions__lt: 
        :param str positions__gte: 
        :param str positions__gt: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str device_id__n: 
        :param str device__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'type', 'positions', 'description', 'q', 'region_id', 'region', 'site_id', 'site', 'device_id', 'device', 'tag', 'cabled', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'type__n', 'positions__n', 'positions__lte', 'positions__lt', 'positions__gte', 'positions__gt', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'device_id__n', 'device__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_ports_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'positions' in params:
            query_params.append(('positions', params['positions']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501
        if 'device' in params:
            query_params.append(('device', params['device']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'cabled' in params:
            query_params.append(('cabled', params['cabled']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'positions__n' in params:
            query_params.append(('positions__n', params['positions__n']))  # noqa: E501
        if 'positions__lte' in params:
            query_params.append(('positions__lte', params['positions__lte']))  # noqa: E501
        if 'positions__lt' in params:
            query_params.append(('positions__lt', params['positions__lt']))  # noqa: E501
        if 'positions__gte' in params:
            query_params.append(('positions__gte', params['positions__gte']))  # noqa: E501
        if 'positions__gt' in params:
            query_params.append(('positions__gt', params['positions__gt']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'device_id__n' in params:
            query_params.append(('device_id__n', params['device_id__n']))  # noqa: E501
        if 'device__n' in params:
            query_params.append(('device__n', params['device__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-ports/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20033',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_ports_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rear_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port. (required)
        :param WritableRearPort data: (required)
        :return: RearPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_ports_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rear_ports_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rear_ports_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port. (required)
        :param WritableRearPort data: (required)
        :return: RearPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_ports_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rear_ports_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rear_ports_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-ports/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RearPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_ports_read(self, id, **kwargs):  # noqa: E501
        """dcim_rear_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port. (required)
        :return: RearPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_ports_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_ports_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_rear_ports_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_rear_ports_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port. (required)
        :return: RearPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_ports_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rear_ports_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-ports/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RearPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_rear_ports_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_rear_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port. (required)
        :param WritableRearPort data: (required)
        :return: RearPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_rear_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_rear_ports_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_rear_ports_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_rear_ports_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_rear_ports_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this rear port. (required)
        :param WritableRearPort data: (required)
        :return: RearPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_rear_ports_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_rear_ports_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_rear_ports_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/rear-ports/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RearPort',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_regions_create(self, data, **kwargs):  # noqa: E501
        """dcim_regions_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRegion data: (required)
        :return: Region
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_regions_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_regions_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_regions_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_regions_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableRegion data: (required)
        :return: Region
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_regions_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_regions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/regions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Region',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_regions_delete(self, id, **kwargs):  # noqa: E501
        """dcim_regions_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this region. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_regions_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_regions_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_regions_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_regions_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this region. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_regions_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_regions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/regions/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_regions_list(self, **kwargs):  # noqa: E501
        """dcim_regions_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str description: 
        :param str q: 
        :param str parent_id: 
        :param str parent: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str parent_id__n: 
        :param str parent__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_regions_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_regions_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_regions_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_regions_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str description: 
        :param str q: 
        :param str parent_id: 
        :param str parent: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str description__n: 
        :param str description__ic: 
        :param str description__nic: 
        :param str description__iew: 
        :param str description__niew: 
        :param str description__isw: 
        :param str description__nisw: 
        :param str description__ie: 
        :param str description__nie: 
        :param str parent_id__n: 
        :param str parent__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'description', 'q', 'parent_id', 'parent', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'description__n', 'description__ic', 'description__nic', 'description__iew', 'description__niew', 'description__isw', 'description__nisw', 'description__ie', 'description__nie', 'parent_id__n', 'parent__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_regions_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'parent_id' in params:
            query_params.append(('parent_id', params['parent_id']))  # noqa: E501
        if 'parent' in params:
            query_params.append(('parent', params['parent']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'description__n' in params:
            query_params.append(('description__n', params['description__n']))  # noqa: E501
        if 'description__ic' in params:
            query_params.append(('description__ic', params['description__ic']))  # noqa: E501
        if 'description__nic' in params:
            query_params.append(('description__nic', params['description__nic']))  # noqa: E501
        if 'description__iew' in params:
            query_params.append(('description__iew', params['description__iew']))  # noqa: E501
        if 'description__niew' in params:
            query_params.append(('description__niew', params['description__niew']))  # noqa: E501
        if 'description__isw' in params:
            query_params.append(('description__isw', params['description__isw']))  # noqa: E501
        if 'description__nisw' in params:
            query_params.append(('description__nisw', params['description__nisw']))  # noqa: E501
        if 'description__ie' in params:
            query_params.append(('description__ie', params['description__ie']))  # noqa: E501
        if 'description__nie' in params:
            query_params.append(('description__nie', params['description__nie']))  # noqa: E501
        if 'parent_id__n' in params:
            query_params.append(('parent_id__n', params['parent_id__n']))  # noqa: E501
        if 'parent__n' in params:
            query_params.append(('parent__n', params['parent__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/regions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20034',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_regions_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_regions_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this region. (required)
        :param WritableRegion data: (required)
        :return: Region
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_regions_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_regions_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_regions_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_regions_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this region. (required)
        :param WritableRegion data: (required)
        :return: Region
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_regions_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_regions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_regions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/regions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Region',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_regions_read(self, id, **kwargs):  # noqa: E501
        """dcim_regions_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this region. (required)
        :return: Region
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_regions_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_regions_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_regions_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_regions_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this region. (required)
        :return: Region
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_regions_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_regions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/regions/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Region',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_regions_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_regions_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this region. (required)
        :param WritableRegion data: (required)
        :return: Region
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_regions_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_regions_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_regions_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_regions_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_regions_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this region. (required)
        :param WritableRegion data: (required)
        :return: Region
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_regions_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_regions_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_regions_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/regions/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Region',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_sites_create(self, data, **kwargs):  # noqa: E501
        """dcim_sites_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableSite data: (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_sites_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_sites_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_sites_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_sites_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableSite data: (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_sites_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_sites_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/sites/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Site',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_sites_delete(self, id, **kwargs):  # noqa: E501
        """dcim_sites_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_sites_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_sites_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_sites_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_sites_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_sites_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_sites_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/sites/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_sites_graphs(self, id, **kwargs):  # noqa: E501
        """dcim_sites_graphs  # noqa: E501

        A convenience method for rendering graphs for a particular site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_graphs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_sites_graphs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_sites_graphs_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_sites_graphs_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_sites_graphs  # noqa: E501

        A convenience method for rendering graphs for a particular site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_graphs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_sites_graphs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_sites_graphs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/sites/{id}/graphs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Site',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_sites_list(self, **kwargs):  # noqa: E501
        """dcim_sites_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str facility: 
        :param str asn: 
        :param str latitude: 
        :param str longitude: 
        :param str contact_name: 
        :param str contact_phone: 
        :param str contact_email: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str status: 
        :param str region_id: 
        :param str region: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str facility__n: 
        :param str facility__ic: 
        :param str facility__nic: 
        :param str facility__iew: 
        :param str facility__niew: 
        :param str facility__isw: 
        :param str facility__nisw: 
        :param str facility__ie: 
        :param str facility__nie: 
        :param str asn__n: 
        :param str asn__lte: 
        :param str asn__lt: 
        :param str asn__gte: 
        :param str asn__gt: 
        :param str latitude__n: 
        :param str latitude__lte: 
        :param str latitude__lt: 
        :param str latitude__gte: 
        :param str latitude__gt: 
        :param str longitude__n: 
        :param str longitude__lte: 
        :param str longitude__lt: 
        :param str longitude__gte: 
        :param str longitude__gt: 
        :param str contact_name__n: 
        :param str contact_name__ic: 
        :param str contact_name__nic: 
        :param str contact_name__iew: 
        :param str contact_name__niew: 
        :param str contact_name__isw: 
        :param str contact_name__nisw: 
        :param str contact_name__ie: 
        :param str contact_name__nie: 
        :param str contact_phone__n: 
        :param str contact_phone__ic: 
        :param str contact_phone__nic: 
        :param str contact_phone__iew: 
        :param str contact_phone__niew: 
        :param str contact_phone__isw: 
        :param str contact_phone__nisw: 
        :param str contact_phone__ie: 
        :param str contact_phone__nie: 
        :param str contact_email__n: 
        :param str contact_email__ic: 
        :param str contact_email__nic: 
        :param str contact_email__iew: 
        :param str contact_email__niew: 
        :param str contact_email__isw: 
        :param str contact_email__nisw: 
        :param str contact_email__ie: 
        :param str contact_email__nie: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_sites_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_sites_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_sites_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_sites_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str facility: 
        :param str asn: 
        :param str latitude: 
        :param str longitude: 
        :param str contact_name: 
        :param str contact_phone: 
        :param str contact_email: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str status: 
        :param str region_id: 
        :param str region: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str facility__n: 
        :param str facility__ic: 
        :param str facility__nic: 
        :param str facility__iew: 
        :param str facility__niew: 
        :param str facility__isw: 
        :param str facility__nisw: 
        :param str facility__ie: 
        :param str facility__nie: 
        :param str asn__n: 
        :param str asn__lte: 
        :param str asn__lt: 
        :param str asn__gte: 
        :param str asn__gt: 
        :param str latitude__n: 
        :param str latitude__lte: 
        :param str latitude__lt: 
        :param str latitude__gte: 
        :param str latitude__gt: 
        :param str longitude__n: 
        :param str longitude__lte: 
        :param str longitude__lt: 
        :param str longitude__gte: 
        :param str longitude__gt: 
        :param str contact_name__n: 
        :param str contact_name__ic: 
        :param str contact_name__nic: 
        :param str contact_name__iew: 
        :param str contact_name__niew: 
        :param str contact_name__isw: 
        :param str contact_name__nisw: 
        :param str contact_name__ie: 
        :param str contact_name__nie: 
        :param str contact_phone__n: 
        :param str contact_phone__ic: 
        :param str contact_phone__nic: 
        :param str contact_phone__iew: 
        :param str contact_phone__niew: 
        :param str contact_phone__isw: 
        :param str contact_phone__nisw: 
        :param str contact_phone__ie: 
        :param str contact_phone__nie: 
        :param str contact_email__n: 
        :param str contact_email__ic: 
        :param str contact_email__nic: 
        :param str contact_email__iew: 
        :param str contact_email__niew: 
        :param str contact_email__isw: 
        :param str contact_email__nisw: 
        :param str contact_email__ie: 
        :param str contact_email__nie: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str status__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'facility', 'asn', 'latitude', 'longitude', 'contact_name', 'contact_phone', 'contact_email', 'tenant_group_id', 'tenant_group', 'tenant_id', 'tenant', 'created', 'created__gte', 'created__lte', 'last_updated', 'last_updated__gte', 'last_updated__lte', 'q', 'status', 'region_id', 'region', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'facility__n', 'facility__ic', 'facility__nic', 'facility__iew', 'facility__niew', 'facility__isw', 'facility__nisw', 'facility__ie', 'facility__nie', 'asn__n', 'asn__lte', 'asn__lt', 'asn__gte', 'asn__gt', 'latitude__n', 'latitude__lte', 'latitude__lt', 'latitude__gte', 'latitude__gt', 'longitude__n', 'longitude__lte', 'longitude__lt', 'longitude__gte', 'longitude__gt', 'contact_name__n', 'contact_name__ic', 'contact_name__nic', 'contact_name__iew', 'contact_name__niew', 'contact_name__isw', 'contact_name__nisw', 'contact_name__ie', 'contact_name__nie', 'contact_phone__n', 'contact_phone__ic', 'contact_phone__nic', 'contact_phone__iew', 'contact_phone__niew', 'contact_phone__isw', 'contact_phone__nisw', 'contact_phone__ie', 'contact_phone__nie', 'contact_email__n', 'contact_email__ic', 'contact_email__nic', 'contact_email__iew', 'contact_email__niew', 'contact_email__isw', 'contact_email__nisw', 'contact_email__ie', 'contact_email__nie', 'tenant_group_id__n', 'tenant_group__n', 'tenant_id__n', 'tenant__n', 'status__n', 'region_id__n', 'region__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_sites_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'facility' in params:
            query_params.append(('facility', params['facility']))  # noqa: E501
        if 'asn' in params:
            query_params.append(('asn', params['asn']))  # noqa: E501
        if 'latitude' in params:
            query_params.append(('latitude', params['latitude']))  # noqa: E501
        if 'longitude' in params:
            query_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'contact_name' in params:
            query_params.append(('contact_name', params['contact_name']))  # noqa: E501
        if 'contact_phone' in params:
            query_params.append(('contact_phone', params['contact_phone']))  # noqa: E501
        if 'contact_email' in params:
            query_params.append(('contact_email', params['contact_email']))  # noqa: E501
        if 'tenant_group_id' in params:
            query_params.append(('tenant_group_id', params['tenant_group_id']))  # noqa: E501
        if 'tenant_group' in params:
            query_params.append(('tenant_group', params['tenant_group']))  # noqa: E501
        if 'tenant_id' in params:
            query_params.append(('tenant_id', params['tenant_id']))  # noqa: E501
        if 'tenant' in params:
            query_params.append(('tenant', params['tenant']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('created__gte', params['created__gte']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('created__lte', params['created__lte']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('last_updated', params['last_updated']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'facility__n' in params:
            query_params.append(('facility__n', params['facility__n']))  # noqa: E501
        if 'facility__ic' in params:
            query_params.append(('facility__ic', params['facility__ic']))  # noqa: E501
        if 'facility__nic' in params:
            query_params.append(('facility__nic', params['facility__nic']))  # noqa: E501
        if 'facility__iew' in params:
            query_params.append(('facility__iew', params['facility__iew']))  # noqa: E501
        if 'facility__niew' in params:
            query_params.append(('facility__niew', params['facility__niew']))  # noqa: E501
        if 'facility__isw' in params:
            query_params.append(('facility__isw', params['facility__isw']))  # noqa: E501
        if 'facility__nisw' in params:
            query_params.append(('facility__nisw', params['facility__nisw']))  # noqa: E501
        if 'facility__ie' in params:
            query_params.append(('facility__ie', params['facility__ie']))  # noqa: E501
        if 'facility__nie' in params:
            query_params.append(('facility__nie', params['facility__nie']))  # noqa: E501
        if 'asn__n' in params:
            query_params.append(('asn__n', params['asn__n']))  # noqa: E501
        if 'asn__lte' in params:
            query_params.append(('asn__lte', params['asn__lte']))  # noqa: E501
        if 'asn__lt' in params:
            query_params.append(('asn__lt', params['asn__lt']))  # noqa: E501
        if 'asn__gte' in params:
            query_params.append(('asn__gte', params['asn__gte']))  # noqa: E501
        if 'asn__gt' in params:
            query_params.append(('asn__gt', params['asn__gt']))  # noqa: E501
        if 'latitude__n' in params:
            query_params.append(('latitude__n', params['latitude__n']))  # noqa: E501
        if 'latitude__lte' in params:
            query_params.append(('latitude__lte', params['latitude__lte']))  # noqa: E501
        if 'latitude__lt' in params:
            query_params.append(('latitude__lt', params['latitude__lt']))  # noqa: E501
        if 'latitude__gte' in params:
            query_params.append(('latitude__gte', params['latitude__gte']))  # noqa: E501
        if 'latitude__gt' in params:
            query_params.append(('latitude__gt', params['latitude__gt']))  # noqa: E501
        if 'longitude__n' in params:
            query_params.append(('longitude__n', params['longitude__n']))  # noqa: E501
        if 'longitude__lte' in params:
            query_params.append(('longitude__lte', params['longitude__lte']))  # noqa: E501
        if 'longitude__lt' in params:
            query_params.append(('longitude__lt', params['longitude__lt']))  # noqa: E501
        if 'longitude__gte' in params:
            query_params.append(('longitude__gte', params['longitude__gte']))  # noqa: E501
        if 'longitude__gt' in params:
            query_params.append(('longitude__gt', params['longitude__gt']))  # noqa: E501
        if 'contact_name__n' in params:
            query_params.append(('contact_name__n', params['contact_name__n']))  # noqa: E501
        if 'contact_name__ic' in params:
            query_params.append(('contact_name__ic', params['contact_name__ic']))  # noqa: E501
        if 'contact_name__nic' in params:
            query_params.append(('contact_name__nic', params['contact_name__nic']))  # noqa: E501
        if 'contact_name__iew' in params:
            query_params.append(('contact_name__iew', params['contact_name__iew']))  # noqa: E501
        if 'contact_name__niew' in params:
            query_params.append(('contact_name__niew', params['contact_name__niew']))  # noqa: E501
        if 'contact_name__isw' in params:
            query_params.append(('contact_name__isw', params['contact_name__isw']))  # noqa: E501
        if 'contact_name__nisw' in params:
            query_params.append(('contact_name__nisw', params['contact_name__nisw']))  # noqa: E501
        if 'contact_name__ie' in params:
            query_params.append(('contact_name__ie', params['contact_name__ie']))  # noqa: E501
        if 'contact_name__nie' in params:
            query_params.append(('contact_name__nie', params['contact_name__nie']))  # noqa: E501
        if 'contact_phone__n' in params:
            query_params.append(('contact_phone__n', params['contact_phone__n']))  # noqa: E501
        if 'contact_phone__ic' in params:
            query_params.append(('contact_phone__ic', params['contact_phone__ic']))  # noqa: E501
        if 'contact_phone__nic' in params:
            query_params.append(('contact_phone__nic', params['contact_phone__nic']))  # noqa: E501
        if 'contact_phone__iew' in params:
            query_params.append(('contact_phone__iew', params['contact_phone__iew']))  # noqa: E501
        if 'contact_phone__niew' in params:
            query_params.append(('contact_phone__niew', params['contact_phone__niew']))  # noqa: E501
        if 'contact_phone__isw' in params:
            query_params.append(('contact_phone__isw', params['contact_phone__isw']))  # noqa: E501
        if 'contact_phone__nisw' in params:
            query_params.append(('contact_phone__nisw', params['contact_phone__nisw']))  # noqa: E501
        if 'contact_phone__ie' in params:
            query_params.append(('contact_phone__ie', params['contact_phone__ie']))  # noqa: E501
        if 'contact_phone__nie' in params:
            query_params.append(('contact_phone__nie', params['contact_phone__nie']))  # noqa: E501
        if 'contact_email__n' in params:
            query_params.append(('contact_email__n', params['contact_email__n']))  # noqa: E501
        if 'contact_email__ic' in params:
            query_params.append(('contact_email__ic', params['contact_email__ic']))  # noqa: E501
        if 'contact_email__nic' in params:
            query_params.append(('contact_email__nic', params['contact_email__nic']))  # noqa: E501
        if 'contact_email__iew' in params:
            query_params.append(('contact_email__iew', params['contact_email__iew']))  # noqa: E501
        if 'contact_email__niew' in params:
            query_params.append(('contact_email__niew', params['contact_email__niew']))  # noqa: E501
        if 'contact_email__isw' in params:
            query_params.append(('contact_email__isw', params['contact_email__isw']))  # noqa: E501
        if 'contact_email__nisw' in params:
            query_params.append(('contact_email__nisw', params['contact_email__nisw']))  # noqa: E501
        if 'contact_email__ie' in params:
            query_params.append(('contact_email__ie', params['contact_email__ie']))  # noqa: E501
        if 'contact_email__nie' in params:
            query_params.append(('contact_email__nie', params['contact_email__nie']))  # noqa: E501
        if 'tenant_group_id__n' in params:
            query_params.append(('tenant_group_id__n', params['tenant_group_id__n']))  # noqa: E501
        if 'tenant_group__n' in params:
            query_params.append(('tenant_group__n', params['tenant_group__n']))  # noqa: E501
        if 'tenant_id__n' in params:
            query_params.append(('tenant_id__n', params['tenant_id__n']))  # noqa: E501
        if 'tenant__n' in params:
            query_params.append(('tenant__n', params['tenant__n']))  # noqa: E501
        if 'status__n' in params:
            query_params.append(('status__n', params['status__n']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/sites/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20035',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_sites_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_sites_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :param WritableSite data: (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_sites_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_sites_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_sites_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_sites_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :param WritableSite data: (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_sites_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_sites_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_sites_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/sites/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Site',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_sites_read(self, id, **kwargs):  # noqa: E501
        """dcim_sites_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_sites_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_sites_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_sites_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_sites_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_sites_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_sites_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/sites/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Site',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_sites_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_sites_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :param WritableSite data: (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_sites_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_sites_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_sites_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_sites_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_sites_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this site. (required)
        :param WritableSite data: (required)
        :return: Site
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_sites_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_sites_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_sites_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/sites/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Site',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_virtual_chassis_create(self, data, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableVirtualChassis data: (required)
        :return: VirtualChassis
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_virtual_chassis_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_virtual_chassis_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def dcim_virtual_chassis_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableVirtualChassis data: (required)
        :return: VirtualChassis
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_virtual_chassis_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_virtual_chassis_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/virtual-chassis/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualChassis',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_virtual_chassis_delete(self, id, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this virtual chassis. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_virtual_chassis_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_virtual_chassis_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_virtual_chassis_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this virtual chassis. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_virtual_chassis_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_virtual_chassis_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/virtual-chassis/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_virtual_chassis_list(self, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str domain: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str tenant_id: 
        :param str tenant: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str domain__n: 
        :param str domain__ic: 
        :param str domain__nic: 
        :param str domain__iew: 
        :param str domain__niew: 
        :param str domain__isw: 
        :param str domain__nisw: 
        :param str domain__ie: 
        :param str domain__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_virtual_chassis_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.dcim_virtual_chassis_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def dcim_virtual_chassis_list_with_http_info(self, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str domain: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str tenant_id: 
        :param str tenant: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str domain__n: 
        :param str domain__ic: 
        :param str domain__nic: 
        :param str domain__iew: 
        :param str domain__niew: 
        :param str domain__isw: 
        :param str domain__nisw: 
        :param str domain__ie: 
        :param str domain__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'domain', 'q', 'region_id', 'region', 'site_id', 'site', 'tenant_id', 'tenant', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'domain__n', 'domain__ic', 'domain__nic', 'domain__iew', 'domain__niew', 'domain__isw', 'domain__nisw', 'domain__ie', 'domain__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'tenant_id__n', 'tenant__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_virtual_chassis_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'domain' in params:
            query_params.append(('domain', params['domain']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'tenant_id' in params:
            query_params.append(('tenant_id', params['tenant_id']))  # noqa: E501
        if 'tenant' in params:
            query_params.append(('tenant', params['tenant']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'domain__n' in params:
            query_params.append(('domain__n', params['domain__n']))  # noqa: E501
        if 'domain__ic' in params:
            query_params.append(('domain__ic', params['domain__ic']))  # noqa: E501
        if 'domain__nic' in params:
            query_params.append(('domain__nic', params['domain__nic']))  # noqa: E501
        if 'domain__iew' in params:
            query_params.append(('domain__iew', params['domain__iew']))  # noqa: E501
        if 'domain__niew' in params:
            query_params.append(('domain__niew', params['domain__niew']))  # noqa: E501
        if 'domain__isw' in params:
            query_params.append(('domain__isw', params['domain__isw']))  # noqa: E501
        if 'domain__nisw' in params:
            query_params.append(('domain__nisw', params['domain__nisw']))  # noqa: E501
        if 'domain__ie' in params:
            query_params.append(('domain__ie', params['domain__ie']))  # noqa: E501
        if 'domain__nie' in params:
            query_params.append(('domain__nie', params['domain__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'tenant_id__n' in params:
            query_params.append(('tenant_id__n', params['tenant_id__n']))  # noqa: E501
        if 'tenant__n' in params:
            query_params.append(('tenant__n', params['tenant__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/virtual-chassis/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20036',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_virtual_chassis_partial_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this virtual chassis. (required)
        :param WritableVirtualChassis data: (required)
        :return: VirtualChassis
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_virtual_chassis_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_virtual_chassis_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_virtual_chassis_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this virtual chassis. (required)
        :param WritableVirtualChassis data: (required)
        :return: VirtualChassis
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_virtual_chassis_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_virtual_chassis_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_virtual_chassis_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/virtual-chassis/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualChassis',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_virtual_chassis_read(self, id, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this virtual chassis. (required)
        :return: VirtualChassis
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_virtual_chassis_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_virtual_chassis_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def dcim_virtual_chassis_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this virtual chassis. (required)
        :return: VirtualChassis
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_virtual_chassis_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_virtual_chassis_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/virtual-chassis/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualChassis',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dcim_virtual_chassis_update(self, id, data, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this virtual chassis. (required)
        :param WritableVirtualChassis data: (required)
        :return: VirtualChassis
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.dcim_virtual_chassis_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.dcim_virtual_chassis_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def dcim_virtual_chassis_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """dcim_virtual_chassis_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dcim_virtual_chassis_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this virtual chassis. (required)
        :param WritableVirtualChassis data: (required)
        :return: VirtualChassis
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dcim_virtual_chassis_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `dcim_virtual_chassis_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `dcim_virtual_chassis_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/dcim/virtual-chassis/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualChassis',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
