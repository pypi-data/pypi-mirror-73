# coding: utf-8

"""
    NetBox API

    API to access NetBox  # noqa: E501

    OpenAPI spec version: 2.8
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from netbox_client.api_client import ApiClient


class CircuitsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def circuits_circuit_terminations_create(self, data, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableCircuitTermination data: (required)
        :return: CircuitTermination
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_terminations_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_terminations_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_terminations_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableCircuitTermination data: (required)
        :return: CircuitTermination
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_terminations_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuit_terminations_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-terminations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CircuitTermination',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_terminations_delete(self, id, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit termination. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_terminations_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_terminations_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_terminations_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit termination. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_terminations_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuit_terminations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-terminations/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_terminations_list(self, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str term_side: 
        :param str port_speed: 
        :param str upstream_speed: 
        :param str xconnect_id: 
        :param str q: 
        :param str circuit_id: 
        :param str site_id: 
        :param str site: 
        :param str term_side__n: 
        :param str port_speed__n: 
        :param str port_speed__lte: 
        :param str port_speed__lt: 
        :param str port_speed__gte: 
        :param str port_speed__gt: 
        :param str upstream_speed__n: 
        :param str upstream_speed__lte: 
        :param str upstream_speed__lt: 
        :param str upstream_speed__gte: 
        :param str upstream_speed__gt: 
        :param str xconnect_id__n: 
        :param str xconnect_id__ic: 
        :param str xconnect_id__nic: 
        :param str xconnect_id__iew: 
        :param str xconnect_id__niew: 
        :param str xconnect_id__isw: 
        :param str xconnect_id__nisw: 
        :param str xconnect_id__ie: 
        :param str xconnect_id__nie: 
        :param str circuit_id__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_terminations_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_terminations_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def circuits_circuit_terminations_list_with_http_info(self, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str term_side: 
        :param str port_speed: 
        :param str upstream_speed: 
        :param str xconnect_id: 
        :param str q: 
        :param str circuit_id: 
        :param str site_id: 
        :param str site: 
        :param str term_side__n: 
        :param str port_speed__n: 
        :param str port_speed__lte: 
        :param str port_speed__lt: 
        :param str port_speed__gte: 
        :param str port_speed__gt: 
        :param str upstream_speed__n: 
        :param str upstream_speed__lte: 
        :param str upstream_speed__lt: 
        :param str upstream_speed__gte: 
        :param str upstream_speed__gt: 
        :param str xconnect_id__n: 
        :param str xconnect_id__ic: 
        :param str xconnect_id__nic: 
        :param str xconnect_id__iew: 
        :param str xconnect_id__niew: 
        :param str xconnect_id__isw: 
        :param str xconnect_id__nisw: 
        :param str xconnect_id__ie: 
        :param str xconnect_id__nie: 
        :param str circuit_id__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_side', 'port_speed', 'upstream_speed', 'xconnect_id', 'q', 'circuit_id', 'site_id', 'site', 'term_side__n', 'port_speed__n', 'port_speed__lte', 'port_speed__lt', 'port_speed__gte', 'port_speed__gt', 'upstream_speed__n', 'upstream_speed__lte', 'upstream_speed__lt', 'upstream_speed__gte', 'upstream_speed__gt', 'xconnect_id__n', 'xconnect_id__ic', 'xconnect_id__nic', 'xconnect_id__iew', 'xconnect_id__niew', 'xconnect_id__isw', 'xconnect_id__nisw', 'xconnect_id__ie', 'xconnect_id__nie', 'circuit_id__n', 'site_id__n', 'site__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_terminations_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'term_side' in params:
            query_params.append(('term_side', params['term_side']))  # noqa: E501
        if 'port_speed' in params:
            query_params.append(('port_speed', params['port_speed']))  # noqa: E501
        if 'upstream_speed' in params:
            query_params.append(('upstream_speed', params['upstream_speed']))  # noqa: E501
        if 'xconnect_id' in params:
            query_params.append(('xconnect_id', params['xconnect_id']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'circuit_id' in params:
            query_params.append(('circuit_id', params['circuit_id']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'term_side__n' in params:
            query_params.append(('term_side__n', params['term_side__n']))  # noqa: E501
        if 'port_speed__n' in params:
            query_params.append(('port_speed__n', params['port_speed__n']))  # noqa: E501
        if 'port_speed__lte' in params:
            query_params.append(('port_speed__lte', params['port_speed__lte']))  # noqa: E501
        if 'port_speed__lt' in params:
            query_params.append(('port_speed__lt', params['port_speed__lt']))  # noqa: E501
        if 'port_speed__gte' in params:
            query_params.append(('port_speed__gte', params['port_speed__gte']))  # noqa: E501
        if 'port_speed__gt' in params:
            query_params.append(('port_speed__gt', params['port_speed__gt']))  # noqa: E501
        if 'upstream_speed__n' in params:
            query_params.append(('upstream_speed__n', params['upstream_speed__n']))  # noqa: E501
        if 'upstream_speed__lte' in params:
            query_params.append(('upstream_speed__lte', params['upstream_speed__lte']))  # noqa: E501
        if 'upstream_speed__lt' in params:
            query_params.append(('upstream_speed__lt', params['upstream_speed__lt']))  # noqa: E501
        if 'upstream_speed__gte' in params:
            query_params.append(('upstream_speed__gte', params['upstream_speed__gte']))  # noqa: E501
        if 'upstream_speed__gt' in params:
            query_params.append(('upstream_speed__gt', params['upstream_speed__gt']))  # noqa: E501
        if 'xconnect_id__n' in params:
            query_params.append(('xconnect_id__n', params['xconnect_id__n']))  # noqa: E501
        if 'xconnect_id__ic' in params:
            query_params.append(('xconnect_id__ic', params['xconnect_id__ic']))  # noqa: E501
        if 'xconnect_id__nic' in params:
            query_params.append(('xconnect_id__nic', params['xconnect_id__nic']))  # noqa: E501
        if 'xconnect_id__iew' in params:
            query_params.append(('xconnect_id__iew', params['xconnect_id__iew']))  # noqa: E501
        if 'xconnect_id__niew' in params:
            query_params.append(('xconnect_id__niew', params['xconnect_id__niew']))  # noqa: E501
        if 'xconnect_id__isw' in params:
            query_params.append(('xconnect_id__isw', params['xconnect_id__isw']))  # noqa: E501
        if 'xconnect_id__nisw' in params:
            query_params.append(('xconnect_id__nisw', params['xconnect_id__nisw']))  # noqa: E501
        if 'xconnect_id__ie' in params:
            query_params.append(('xconnect_id__ie', params['xconnect_id__ie']))  # noqa: E501
        if 'xconnect_id__nie' in params:
            query_params.append(('xconnect_id__nie', params['xconnect_id__nie']))  # noqa: E501
        if 'circuit_id__n' in params:
            query_params.append(('circuit_id__n', params['circuit_id__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-terminations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_terminations_partial_update(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit termination. (required)
        :param WritableCircuitTermination data: (required)
        :return: CircuitTermination
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_terminations_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_terminations_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_terminations_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit termination. (required)
        :param WritableCircuitTermination data: (required)
        :return: CircuitTermination
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_terminations_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuit_terminations_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuit_terminations_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-terminations/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CircuitTermination',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_terminations_read(self, id, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit termination. (required)
        :return: CircuitTermination
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_terminations_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_terminations_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_terminations_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit termination. (required)
        :return: CircuitTermination
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_terminations_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuit_terminations_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-terminations/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CircuitTermination',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_terminations_update(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit termination. (required)
        :param WritableCircuitTermination data: (required)
        :return: CircuitTermination
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_terminations_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_terminations_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_terminations_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuit_terminations_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_terminations_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit termination. (required)
        :param WritableCircuitTermination data: (required)
        :return: CircuitTermination
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_terminations_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuit_terminations_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuit_terminations_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-terminations/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CircuitTermination',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_types_create(self, data, **kwargs):  # noqa: E501
        """circuits_circuit_types_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CircuitType data: (required)
        :return: CircuitType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_types_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_types_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_types_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """circuits_circuit_types_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CircuitType data: (required)
        :return: CircuitType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_types_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuit_types_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-types/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CircuitType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_types_delete(self, id, **kwargs):  # noqa: E501
        """circuits_circuit_types_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_types_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_types_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_types_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_circuit_types_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_types_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuit_types_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-types/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_types_list(self, **kwargs):  # noqa: E501
        """circuits_circuit_types_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str q: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_types_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_types_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def circuits_circuit_types_list_with_http_info(self, **kwargs):  # noqa: E501
        """circuits_circuit_types_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str q: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'q', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_types_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-types/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_types_partial_update(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuit_types_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit type. (required)
        :param CircuitType data: (required)
        :return: CircuitType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_types_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_types_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_types_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuit_types_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit type. (required)
        :param CircuitType data: (required)
        :return: CircuitType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_types_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuit_types_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuit_types_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-types/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CircuitType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_types_read(self, id, **kwargs):  # noqa: E501
        """circuits_circuit_types_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit type. (required)
        :return: CircuitType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_types_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_types_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_types_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_circuit_types_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit type. (required)
        :return: CircuitType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_types_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuit_types_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-types/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CircuitType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuit_types_update(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuit_types_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit type. (required)
        :param CircuitType data: (required)
        :return: CircuitType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuit_types_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuit_types_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def circuits_circuit_types_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuit_types_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuit_types_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit type. (required)
        :param CircuitType data: (required)
        :return: CircuitType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuit_types_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuit_types_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuit_types_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuit-types/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CircuitType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuits_create(self, data, **kwargs):  # noqa: E501
        """circuits_circuits_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableCircuit data: (required)
        :return: Circuit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuits_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuits_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def circuits_circuits_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """circuits_circuits_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WritableCircuit data: (required)
        :return: Circuit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuits_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuits_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuits/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Circuit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuits_delete(self, id, **kwargs):  # noqa: E501
        """circuits_circuits_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuits_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuits_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_circuits_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_circuits_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuits_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuits_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuits/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuits_list(self, **kwargs):  # noqa: E501
        """circuits_circuits_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str cid: 
        :param str install_date: 
        :param str commit_rate: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str provider_id: 
        :param str provider: 
        :param str type_id: 
        :param str type: 
        :param str status: 
        :param str site_id: 
        :param str site: 
        :param str region_id: 
        :param str region: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str cid__n: 
        :param str cid__ic: 
        :param str cid__nic: 
        :param str cid__iew: 
        :param str cid__niew: 
        :param str cid__isw: 
        :param str cid__nisw: 
        :param str cid__ie: 
        :param str cid__nie: 
        :param str install_date__n: 
        :param str install_date__lte: 
        :param str install_date__lt: 
        :param str install_date__gte: 
        :param str install_date__gt: 
        :param str commit_rate__n: 
        :param str commit_rate__lte: 
        :param str commit_rate__lt: 
        :param str commit_rate__gte: 
        :param str commit_rate__gt: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str provider_id__n: 
        :param str provider__n: 
        :param str type_id__n: 
        :param str type__n: 
        :param str status__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuits_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuits_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def circuits_circuits_list_with_http_info(self, **kwargs):  # noqa: E501
        """circuits_circuits_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str cid: 
        :param str install_date: 
        :param str commit_rate: 
        :param str tenant_group_id: 
        :param str tenant_group: 
        :param str tenant_id: 
        :param str tenant: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str provider_id: 
        :param str provider: 
        :param str type_id: 
        :param str type: 
        :param str status: 
        :param str site_id: 
        :param str site: 
        :param str region_id: 
        :param str region: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str cid__n: 
        :param str cid__ic: 
        :param str cid__nic: 
        :param str cid__iew: 
        :param str cid__niew: 
        :param str cid__isw: 
        :param str cid__nisw: 
        :param str cid__ie: 
        :param str cid__nie: 
        :param str install_date__n: 
        :param str install_date__lte: 
        :param str install_date__lt: 
        :param str install_date__gte: 
        :param str install_date__gt: 
        :param str commit_rate__n: 
        :param str commit_rate__lte: 
        :param str commit_rate__lt: 
        :param str commit_rate__gte: 
        :param str commit_rate__gt: 
        :param str tenant_group_id__n: 
        :param str tenant_group__n: 
        :param str tenant_id__n: 
        :param str tenant__n: 
        :param str provider_id__n: 
        :param str provider__n: 
        :param str type_id__n: 
        :param str type__n: 
        :param str status__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str region_id__n: 
        :param str region__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'cid', 'install_date', 'commit_rate', 'tenant_group_id', 'tenant_group', 'tenant_id', 'tenant', 'created', 'created__gte', 'created__lte', 'last_updated', 'last_updated__gte', 'last_updated__lte', 'q', 'provider_id', 'provider', 'type_id', 'type', 'status', 'site_id', 'site', 'region_id', 'region', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'cid__n', 'cid__ic', 'cid__nic', 'cid__iew', 'cid__niew', 'cid__isw', 'cid__nisw', 'cid__ie', 'cid__nie', 'install_date__n', 'install_date__lte', 'install_date__lt', 'install_date__gte', 'install_date__gt', 'commit_rate__n', 'commit_rate__lte', 'commit_rate__lt', 'commit_rate__gte', 'commit_rate__gt', 'tenant_group_id__n', 'tenant_group__n', 'tenant_id__n', 'tenant__n', 'provider_id__n', 'provider__n', 'type_id__n', 'type__n', 'status__n', 'site_id__n', 'site__n', 'region_id__n', 'region__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuits_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'cid' in params:
            query_params.append(('cid', params['cid']))  # noqa: E501
        if 'install_date' in params:
            query_params.append(('install_date', params['install_date']))  # noqa: E501
        if 'commit_rate' in params:
            query_params.append(('commit_rate', params['commit_rate']))  # noqa: E501
        if 'tenant_group_id' in params:
            query_params.append(('tenant_group_id', params['tenant_group_id']))  # noqa: E501
        if 'tenant_group' in params:
            query_params.append(('tenant_group', params['tenant_group']))  # noqa: E501
        if 'tenant_id' in params:
            query_params.append(('tenant_id', params['tenant_id']))  # noqa: E501
        if 'tenant' in params:
            query_params.append(('tenant', params['tenant']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('created__gte', params['created__gte']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('created__lte', params['created__lte']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('last_updated', params['last_updated']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'provider_id' in params:
            query_params.append(('provider_id', params['provider_id']))  # noqa: E501
        if 'provider' in params:
            query_params.append(('provider', params['provider']))  # noqa: E501
        if 'type_id' in params:
            query_params.append(('type_id', params['type_id']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'cid__n' in params:
            query_params.append(('cid__n', params['cid__n']))  # noqa: E501
        if 'cid__ic' in params:
            query_params.append(('cid__ic', params['cid__ic']))  # noqa: E501
        if 'cid__nic' in params:
            query_params.append(('cid__nic', params['cid__nic']))  # noqa: E501
        if 'cid__iew' in params:
            query_params.append(('cid__iew', params['cid__iew']))  # noqa: E501
        if 'cid__niew' in params:
            query_params.append(('cid__niew', params['cid__niew']))  # noqa: E501
        if 'cid__isw' in params:
            query_params.append(('cid__isw', params['cid__isw']))  # noqa: E501
        if 'cid__nisw' in params:
            query_params.append(('cid__nisw', params['cid__nisw']))  # noqa: E501
        if 'cid__ie' in params:
            query_params.append(('cid__ie', params['cid__ie']))  # noqa: E501
        if 'cid__nie' in params:
            query_params.append(('cid__nie', params['cid__nie']))  # noqa: E501
        if 'install_date__n' in params:
            query_params.append(('install_date__n', params['install_date__n']))  # noqa: E501
        if 'install_date__lte' in params:
            query_params.append(('install_date__lte', params['install_date__lte']))  # noqa: E501
        if 'install_date__lt' in params:
            query_params.append(('install_date__lt', params['install_date__lt']))  # noqa: E501
        if 'install_date__gte' in params:
            query_params.append(('install_date__gte', params['install_date__gte']))  # noqa: E501
        if 'install_date__gt' in params:
            query_params.append(('install_date__gt', params['install_date__gt']))  # noqa: E501
        if 'commit_rate__n' in params:
            query_params.append(('commit_rate__n', params['commit_rate__n']))  # noqa: E501
        if 'commit_rate__lte' in params:
            query_params.append(('commit_rate__lte', params['commit_rate__lte']))  # noqa: E501
        if 'commit_rate__lt' in params:
            query_params.append(('commit_rate__lt', params['commit_rate__lt']))  # noqa: E501
        if 'commit_rate__gte' in params:
            query_params.append(('commit_rate__gte', params['commit_rate__gte']))  # noqa: E501
        if 'commit_rate__gt' in params:
            query_params.append(('commit_rate__gt', params['commit_rate__gt']))  # noqa: E501
        if 'tenant_group_id__n' in params:
            query_params.append(('tenant_group_id__n', params['tenant_group_id__n']))  # noqa: E501
        if 'tenant_group__n' in params:
            query_params.append(('tenant_group__n', params['tenant_group__n']))  # noqa: E501
        if 'tenant_id__n' in params:
            query_params.append(('tenant_id__n', params['tenant_id__n']))  # noqa: E501
        if 'tenant__n' in params:
            query_params.append(('tenant__n', params['tenant__n']))  # noqa: E501
        if 'provider_id__n' in params:
            query_params.append(('provider_id__n', params['provider_id__n']))  # noqa: E501
        if 'provider__n' in params:
            query_params.append(('provider__n', params['provider__n']))  # noqa: E501
        if 'type_id__n' in params:
            query_params.append(('type_id__n', params['type_id__n']))  # noqa: E501
        if 'type__n' in params:
            query_params.append(('type__n', params['type__n']))  # noqa: E501
        if 'status__n' in params:
            query_params.append(('status__n', params['status__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuits/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuits_partial_update(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuits_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit. (required)
        :param WritableCircuit data: (required)
        :return: Circuit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuits_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuits_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def circuits_circuits_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuits_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit. (required)
        :param WritableCircuit data: (required)
        :return: Circuit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuits_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuits_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuits_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuits/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Circuit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuits_read(self, id, **kwargs):  # noqa: E501
        """circuits_circuits_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit. (required)
        :return: Circuit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuits_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuits_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_circuits_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_circuits_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit. (required)
        :return: Circuit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuits_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuits_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuits/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Circuit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_circuits_update(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuits_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit. (required)
        :param WritableCircuit data: (required)
        :return: Circuit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_circuits_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_circuits_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def circuits_circuits_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """circuits_circuits_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_circuits_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this circuit. (required)
        :param WritableCircuit data: (required)
        :return: Circuit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_circuits_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_circuits_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_circuits_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/circuits/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Circuit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_providers_create(self, data, **kwargs):  # noqa: E501
        """circuits_providers_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Provider data: (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_providers_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_providers_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def circuits_providers_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """circuits_providers_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Provider data: (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_providers_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_providers_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/providers/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Provider',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_providers_delete(self, id, **kwargs):  # noqa: E501
        """circuits_providers_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_providers_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_providers_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_providers_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_providers_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_providers_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_providers_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/providers/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_providers_graphs(self, id, **kwargs):  # noqa: E501
        """circuits_providers_graphs  # noqa: E501

        A convenience method for rendering graphs for a particular provider.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_graphs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_providers_graphs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_providers_graphs_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_providers_graphs_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_providers_graphs  # noqa: E501

        A convenience method for rendering graphs for a particular provider.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_graphs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_providers_graphs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_providers_graphs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/providers/{id}/graphs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Provider',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_providers_list(self, **kwargs):  # noqa: E501
        """circuits_providers_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str asn: 
        :param str account: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str asn__n: 
        :param str asn__lte: 
        :param str asn__lt: 
        :param str asn__gte: 
        :param str asn__gt: 
        :param str account__n: 
        :param str account__ic: 
        :param str account__nic: 
        :param str account__iew: 
        :param str account__niew: 
        :param str account__isw: 
        :param str account__nisw: 
        :param str account__ie: 
        :param str account__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_providers_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.circuits_providers_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def circuits_providers_list_with_http_info(self, **kwargs):  # noqa: E501
        """circuits_providers_list  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: 
        :param str name: 
        :param str slug: 
        :param str asn: 
        :param str account: 
        :param str created: 
        :param str created__gte: 
        :param str created__lte: 
        :param str last_updated: 
        :param str last_updated__gte: 
        :param str last_updated__lte: 
        :param str q: 
        :param str region_id: 
        :param str region: 
        :param str site_id: 
        :param str site: 
        :param str tag: 
        :param str id__n: 
        :param str id__lte: 
        :param str id__lt: 
        :param str id__gte: 
        :param str id__gt: 
        :param str name__n: 
        :param str name__ic: 
        :param str name__nic: 
        :param str name__iew: 
        :param str name__niew: 
        :param str name__isw: 
        :param str name__nisw: 
        :param str name__ie: 
        :param str name__nie: 
        :param str slug__n: 
        :param str slug__ic: 
        :param str slug__nic: 
        :param str slug__iew: 
        :param str slug__niew: 
        :param str slug__isw: 
        :param str slug__nisw: 
        :param str slug__ie: 
        :param str slug__nie: 
        :param str asn__n: 
        :param str asn__lte: 
        :param str asn__lt: 
        :param str asn__gte: 
        :param str asn__gt: 
        :param str account__n: 
        :param str account__ic: 
        :param str account__nic: 
        :param str account__iew: 
        :param str account__niew: 
        :param str account__isw: 
        :param str account__nisw: 
        :param str account__ie: 
        :param str account__nie: 
        :param str region_id__n: 
        :param str region__n: 
        :param str site_id__n: 
        :param str site__n: 
        :param str tag__n: 
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'slug', 'asn', 'account', 'created', 'created__gte', 'created__lte', 'last_updated', 'last_updated__gte', 'last_updated__lte', 'q', 'region_id', 'region', 'site_id', 'site', 'tag', 'id__n', 'id__lte', 'id__lt', 'id__gte', 'id__gt', 'name__n', 'name__ic', 'name__nic', 'name__iew', 'name__niew', 'name__isw', 'name__nisw', 'name__ie', 'name__nie', 'slug__n', 'slug__ic', 'slug__nic', 'slug__iew', 'slug__niew', 'slug__isw', 'slug__nisw', 'slug__ie', 'slug__nie', 'asn__n', 'asn__lte', 'asn__lt', 'asn__gte', 'asn__gt', 'account__n', 'account__ic', 'account__nic', 'account__iew', 'account__niew', 'account__isw', 'account__nisw', 'account__ie', 'account__nie', 'region_id__n', 'region__n', 'site_id__n', 'site__n', 'tag__n', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_providers_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'slug' in params:
            query_params.append(('slug', params['slug']))  # noqa: E501
        if 'asn' in params:
            query_params.append(('asn', params['asn']))  # noqa: E501
        if 'account' in params:
            query_params.append(('account', params['account']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('created__gte', params['created__gte']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('created__lte', params['created__lte']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('last_updated', params['last_updated']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'region_id' in params:
            query_params.append(('region_id', params['region_id']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'site' in params:
            query_params.append(('site', params['site']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'id__n' in params:
            query_params.append(('id__n', params['id__n']))  # noqa: E501
        if 'id__lte' in params:
            query_params.append(('id__lte', params['id__lte']))  # noqa: E501
        if 'id__lt' in params:
            query_params.append(('id__lt', params['id__lt']))  # noqa: E501
        if 'id__gte' in params:
            query_params.append(('id__gte', params['id__gte']))  # noqa: E501
        if 'id__gt' in params:
            query_params.append(('id__gt', params['id__gt']))  # noqa: E501
        if 'name__n' in params:
            query_params.append(('name__n', params['name__n']))  # noqa: E501
        if 'name__ic' in params:
            query_params.append(('name__ic', params['name__ic']))  # noqa: E501
        if 'name__nic' in params:
            query_params.append(('name__nic', params['name__nic']))  # noqa: E501
        if 'name__iew' in params:
            query_params.append(('name__iew', params['name__iew']))  # noqa: E501
        if 'name__niew' in params:
            query_params.append(('name__niew', params['name__niew']))  # noqa: E501
        if 'name__isw' in params:
            query_params.append(('name__isw', params['name__isw']))  # noqa: E501
        if 'name__nisw' in params:
            query_params.append(('name__nisw', params['name__nisw']))  # noqa: E501
        if 'name__ie' in params:
            query_params.append(('name__ie', params['name__ie']))  # noqa: E501
        if 'name__nie' in params:
            query_params.append(('name__nie', params['name__nie']))  # noqa: E501
        if 'slug__n' in params:
            query_params.append(('slug__n', params['slug__n']))  # noqa: E501
        if 'slug__ic' in params:
            query_params.append(('slug__ic', params['slug__ic']))  # noqa: E501
        if 'slug__nic' in params:
            query_params.append(('slug__nic', params['slug__nic']))  # noqa: E501
        if 'slug__iew' in params:
            query_params.append(('slug__iew', params['slug__iew']))  # noqa: E501
        if 'slug__niew' in params:
            query_params.append(('slug__niew', params['slug__niew']))  # noqa: E501
        if 'slug__isw' in params:
            query_params.append(('slug__isw', params['slug__isw']))  # noqa: E501
        if 'slug__nisw' in params:
            query_params.append(('slug__nisw', params['slug__nisw']))  # noqa: E501
        if 'slug__ie' in params:
            query_params.append(('slug__ie', params['slug__ie']))  # noqa: E501
        if 'slug__nie' in params:
            query_params.append(('slug__nie', params['slug__nie']))  # noqa: E501
        if 'asn__n' in params:
            query_params.append(('asn__n', params['asn__n']))  # noqa: E501
        if 'asn__lte' in params:
            query_params.append(('asn__lte', params['asn__lte']))  # noqa: E501
        if 'asn__lt' in params:
            query_params.append(('asn__lt', params['asn__lt']))  # noqa: E501
        if 'asn__gte' in params:
            query_params.append(('asn__gte', params['asn__gte']))  # noqa: E501
        if 'asn__gt' in params:
            query_params.append(('asn__gt', params['asn__gt']))  # noqa: E501
        if 'account__n' in params:
            query_params.append(('account__n', params['account__n']))  # noqa: E501
        if 'account__ic' in params:
            query_params.append(('account__ic', params['account__ic']))  # noqa: E501
        if 'account__nic' in params:
            query_params.append(('account__nic', params['account__nic']))  # noqa: E501
        if 'account__iew' in params:
            query_params.append(('account__iew', params['account__iew']))  # noqa: E501
        if 'account__niew' in params:
            query_params.append(('account__niew', params['account__niew']))  # noqa: E501
        if 'account__isw' in params:
            query_params.append(('account__isw', params['account__isw']))  # noqa: E501
        if 'account__nisw' in params:
            query_params.append(('account__nisw', params['account__nisw']))  # noqa: E501
        if 'account__ie' in params:
            query_params.append(('account__ie', params['account__ie']))  # noqa: E501
        if 'account__nie' in params:
            query_params.append(('account__nie', params['account__nie']))  # noqa: E501
        if 'region_id__n' in params:
            query_params.append(('region_id__n', params['region_id__n']))  # noqa: E501
        if 'region__n' in params:
            query_params.append(('region__n', params['region__n']))  # noqa: E501
        if 'site_id__n' in params:
            query_params.append(('site_id__n', params['site_id__n']))  # noqa: E501
        if 'site__n' in params:
            query_params.append(('site__n', params['site__n']))  # noqa: E501
        if 'tag__n' in params:
            query_params.append(('tag__n', params['tag__n']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/providers/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_providers_partial_update(self, id, data, **kwargs):  # noqa: E501
        """circuits_providers_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :param Provider data: (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_providers_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_providers_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def circuits_providers_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """circuits_providers_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :param Provider data: (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_providers_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_providers_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_providers_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/providers/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Provider',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_providers_read(self, id, **kwargs):  # noqa: E501
        """circuits_providers_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_providers_read_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_providers_read_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def circuits_providers_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """circuits_providers_read  # noqa: E501

        Call to super to allow for caching  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_providers_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_providers_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/providers/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Provider',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def circuits_providers_update(self, id, data, **kwargs):  # noqa: E501
        """circuits_providers_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :param Provider data: (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.circuits_providers_update_with_http_info(id, data, **kwargs)  # noqa: E501
        else:
            (data) = self.circuits_providers_update_with_http_info(id, data, **kwargs)  # noqa: E501
            return data

    def circuits_providers_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """circuits_providers_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.circuits_providers_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer value identifying this provider. (required)
        :param Provider data: (required)
        :return: Provider
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method circuits_providers_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `circuits_providers_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `circuits_providers_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/circuits/providers/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Provider',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
