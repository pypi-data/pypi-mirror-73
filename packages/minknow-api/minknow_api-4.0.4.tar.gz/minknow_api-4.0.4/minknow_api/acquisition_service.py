### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from .acquisition_pb2_grpc import *
from . import acquisition_pb2
from minknow_api.acquisition_pb2 import *
from minknow_api._support import MessageWrapper, ArgumentError
import time
import logging

__all__ = [
    "AcquisitionService",
    "StartRequest",
    "StartResponse",
    "StopRequest",
    "StopResponse",
    "WatchForStatusChangeRequest",
    "WatchForStatusChangeResponse",
    "CurrentStatusRequest",
    "CurrentStatusResponse",
    "GetProgressRequest",
    "GetProgressResponse",
    "GetAcquisitionRunInfoRequest",
    "AcquisitionYieldSummary",
    "AcquisitionWriterSummary",
    "ChannelStateInfo",
    "AcquisitionConfigSummary",
    "AcquisitionRunInfo",
    "ListAcquisitionRunsRequest",
    "ListAcquisitionRunsResponse",
    "GetCurrentAcquisitionRunRequest",
    "WatchCurrentAcquisitionRunRequest",
    "SetSignalReaderRequest",
    "SetSignalReaderResponse",
    "MinknowStatus",
    "ERROR_STATUS",
    "READY",
    "STARTING",
    "PROCESSING",
    "FINISHING",
    "Option",
    "AUTO",
    "DISABLE",
    "FORCE",
    "Purpose",
    "OTHER_PURPOSE",
    "SEQUENCING",
    "CALIBRATION",
    "AcquisitionState",
    "ACQUISITION_STARTING",
    "ACQUISITION_RUNNING",
    "ACQUISITION_FINISHING",
    "ACQUISITION_COMPLETED",
    "AcquisitionStopReason",
    "STOPPED_NOT_SET",
    "STOPPED_USER_REQUESTED",
    "STOPPED_NO_DISK_SPACE",
    "STOPPED_DEVICE_STOPPED_ACQUISITION",
    "STOPPED_STARTING_ANOTHER_RUN",
    "STOPPED_PROTOCOL_ENDED",
    "STOPPED_DEVICE_ERROR",
    "FinishingState",
    "FINISHING_UNKNOWN",
    "FINISHING_PROCESSING_DEVICE_SIGNAL",
    "FINISHING_BASECALLING_READS",
    "FINISHING_SAVING_DATA",
]

def run_with_retry(method, message, timeout, unwraps, full_name):
    retry_count = 20
    error = None
    for i in range(retry_count):
        try:
            result = MessageWrapper(method(message, timeout=timeout), unwraps=unwraps)
            return result
        except grpc.RpcError as e:
            # Retrying unidentified grpc errors to keep clients from crashing
            retryable_error = (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details() or \
                                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()))
            if retryable_error:
                logging.info('Bypassed ({}: {}) error for grpc: {}. Attempt {}.'.format(e.code(), e.details(), full_name, i))
            else:
                raise
            error = e
        time.sleep(1)
    raise error


class AcquisitionService(object):
    def __init__(self, channel):
        self._stub = AcquisitionServiceStub(channel)
        self._pb = acquisition_pb2

    def start(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.start, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = StartRequest()

        if "dont_wait_for_device_ready" in kwargs:
            unused_args.remove("dont_wait_for_device_ready")
            _message.dont_wait_for_device_ready = kwargs['dont_wait_for_device_ready']

        if "generate_report" in kwargs:
            unused_args.remove("generate_report")
            _message.generate_report = kwargs['generate_report']

        if "send_sequencing_read_metrics" in kwargs:
            unused_args.remove("send_sequencing_read_metrics")
            _message.send_sequencing_read_metrics = kwargs['send_sequencing_read_metrics']

        if "send_basecalling_metrics" in kwargs:
            unused_args.remove("send_basecalling_metrics")
            _message.send_basecalling_metrics = kwargs['send_basecalling_metrics']

        if "purpose" in kwargs:
            unused_args.remove("purpose")
            _message.purpose = kwargs['purpose']

        if "analysis" in kwargs:
            unused_args.remove("analysis")
            _message.analysis = kwargs['analysis']

        if "file_output" in kwargs:
            unused_args.remove("file_output")
            _message.file_output = kwargs['file_output']

        if "generate_final_summary" in kwargs:
            unused_args.remove("generate_final_summary")
            _message.generate_final_summary = kwargs['generate_final_summary']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to start: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.start, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

    def stop(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.stop, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = StopRequest()

        if "data_action_on_stop" in kwargs:
            unused_args.remove("data_action_on_stop")
            _message.data_action_on_stop = kwargs['data_action_on_stop']

        if "wait_until_ready" in kwargs:
            unused_args.remove("wait_until_ready")
            _message.wait_until_ready = kwargs['wait_until_ready']

        if "keep_power_on" in kwargs:
            unused_args.remove("keep_power_on")
            _message.keep_power_on = kwargs['keep_power_on']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to stop: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.stop, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

    def watch_for_status_change(self, _iterator):
        return self._stub.watch_for_status_change(_iterator)

    def watch_current_acquisition_run(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.watch_current_acquisition_run, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = WatchCurrentAcquisitionRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to watch_current_acquisition_run: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.watch_current_acquisition_run, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

    def current_status(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.current_status, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = CurrentStatusRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to current_status: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.current_status, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

    def get_progress(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.get_progress, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = GetProgressRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to get_progress: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.get_progress, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

    def get_acquisition_info(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.get_acquisition_info, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = GetAcquisitionRunInfoRequest()

        if "run_id" in kwargs:
            unused_args.remove("run_id")
            _message.run_id = kwargs['run_id']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to get_acquisition_info: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.get_acquisition_info, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

    def list_acquisition_runs(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.list_acquisition_runs, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = ListAcquisitionRunsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to list_acquisition_runs: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.list_acquisition_runs, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

    def get_current_acquisition_run(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.get_current_acquisition_run, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = GetCurrentAcquisitionRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to get_current_acquisition_run: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.get_current_acquisition_run, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

    def set_signal_reader(self, _message=None, _timeout=None, **kwargs):
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.set_signal_reader, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = SetSignalReaderRequest()

        if "reader" in kwargs:
            unused_args.remove("reader")
            _message.reader = kwargs['reader']
        else:
            raise ArgumentError("set_signal_reader requires a 'reader' argument")

        if "hdf_source" in kwargs:
            unused_args.remove("hdf_source")
            _message.hdf_source = kwargs['hdf_source']

        if "hdf_mode" in kwargs:
            unused_args.remove("hdf_mode")
            _message.hdf_mode = kwargs['hdf_mode']

        if "sample_rate_scale_factor" in kwargs:
            unused_args.remove("sample_rate_scale_factor")
            _message.sample_rate_scale_factor = kwargs['sample_rate_scale_factor']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to set_signal_reader: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.set_signal_reader, _message, _timeout, [], "minknow_api.acquisition.AcquisitionService")