# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_singa_wrap')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_singa_wrap')
    _singa_wrap = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_singa_wrap', [dirname(__file__)])
        except ImportError:
            import _singa_wrap
            return _singa_wrap
        if fp is not None:
            try:
                _mod = imp.load_module('_singa_wrap', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _singa_wrap = swig_import_helper()
    del swig_import_helper
else:
    import _singa_wrap
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

USE_CBLAS = _singa_wrap.USE_CBLAS
USE_GLOG = _singa_wrap.USE_GLOG
USE_DNNL = _singa_wrap.USE_DNNL
CPU_ONLY = _singa_wrap.CPU_ONLY
SINGA_MAJOR_VERSION = _singa_wrap.SINGA_MAJOR_VERSION
SINGA_MINOR_VERSION = _singa_wrap.SINGA_MINOR_VERSION
SINGA_PATCH_VERSION = _singa_wrap.SINGA_PATCH_VERSION
SINGA_VERSION = _singa_wrap.SINGA_VERSION
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _singa_wrap.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _singa_wrap.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _singa_wrap.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _singa_wrap.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _singa_wrap.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _singa_wrap.SwigPyIterator_equal(self, x)

    def copy(self):
        return _singa_wrap.SwigPyIterator_copy(self)

    def next(self):
        return _singa_wrap.SwigPyIterator_next(self)

    def __next__(self):
        return _singa_wrap.SwigPyIterator___next__(self)

    def previous(self):
        return _singa_wrap.SwigPyIterator_previous(self)

    def advance(self, n):
        return _singa_wrap.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _singa_wrap.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _singa_wrap.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _singa_wrap.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _singa_wrap.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _singa_wrap.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _singa_wrap.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _singa_wrap.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _singa_wrap.SHARED_PTR_DISOWN
class Shape(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Shape, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Shape, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _singa_wrap.Shape_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _singa_wrap.Shape___nonzero__(self)

    def __bool__(self):
        return _singa_wrap.Shape___bool__(self)

    def __len__(self):
        return _singa_wrap.Shape___len__(self)

    def __getslice__(self, i, j):
        return _singa_wrap.Shape___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _singa_wrap.Shape___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _singa_wrap.Shape___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _singa_wrap.Shape___delitem__(self, *args)

    def __getitem__(self, *args):
        return _singa_wrap.Shape___getitem__(self, *args)

    def __setitem__(self, *args):
        return _singa_wrap.Shape___setitem__(self, *args)

    def pop(self):
        return _singa_wrap.Shape_pop(self)

    def append(self, x):
        return _singa_wrap.Shape_append(self, x)

    def empty(self):
        return _singa_wrap.Shape_empty(self)

    def size(self):
        return _singa_wrap.Shape_size(self)

    def swap(self, v):
        return _singa_wrap.Shape_swap(self, v)

    def begin(self):
        return _singa_wrap.Shape_begin(self)

    def end(self):
        return _singa_wrap.Shape_end(self)

    def rbegin(self):
        return _singa_wrap.Shape_rbegin(self)

    def rend(self):
        return _singa_wrap.Shape_rend(self)

    def clear(self):
        return _singa_wrap.Shape_clear(self)

    def get_allocator(self):
        return _singa_wrap.Shape_get_allocator(self)

    def pop_back(self):
        return _singa_wrap.Shape_pop_back(self)

    def erase(self, *args):
        return _singa_wrap.Shape_erase(self, *args)

    def __init__(self, *args):
        this = _singa_wrap.new_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _singa_wrap.Shape_push_back(self, x)

    def front(self):
        return _singa_wrap.Shape_front(self)

    def back(self):
        return _singa_wrap.Shape_back(self)

    def assign(self, n, x):
        return _singa_wrap.Shape_assign(self, n, x)

    def resize(self, *args):
        return _singa_wrap.Shape_resize(self, *args)

    def insert(self, *args):
        return _singa_wrap.Shape_insert(self, *args)

    def reserve(self, n):
        return _singa_wrap.Shape_reserve(self, n)

    def capacity(self):
        return _singa_wrap.Shape_capacity(self)
    __swig_destroy__ = _singa_wrap.delete_Shape
    __del__ = lambda self: None
Shape_swigregister = _singa_wrap.Shape_swigregister
Shape_swigregister(Shape)

kFloat32 = _singa_wrap.kFloat32
kFloat16 = _singa_wrap.kFloat16
kInt = _singa_wrap.kInt
kChar = _singa_wrap.kChar
kDouble = _singa_wrap.kDouble

def Product(shape, start=0, len=0):
    return _singa_wrap.Product(shape, start, len)
Product = _singa_wrap.Product

def SizeOf(t):
    return _singa_wrap.SizeOf(t)
SizeOf = _singa_wrap.SizeOf
class Tensor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tensor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Tensor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _singa_wrap.new_Tensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def device(self):
        return _singa_wrap.Tensor_device(self)

    def GetFloatValue(self, value, num):
        return _singa_wrap.Tensor_GetFloatValue(self, value, num)

    def GetIntValue(self, value, num):
        return _singa_wrap.Tensor_GetIntValue(self, value, num)

    def SetFloatValue(self, x):
        return _singa_wrap.Tensor_SetFloatValue(self, x)

    def data_type(self):
        return _singa_wrap.Tensor_data_type(self)

    def shape(self, *args):
        return _singa_wrap.Tensor_shape(self, *args)

    def transpose(self):
        return _singa_wrap.Tensor_transpose(self)

    def nDim(self):
        return _singa_wrap.Tensor_nDim(self)

    def Size(self):
        return _singa_wrap.Tensor_Size(self)

    def MemSize(self):
        return _singa_wrap.Tensor_MemSize(self)

    def ResetLike(self, t):
        return _singa_wrap.Tensor_ResetLike(self, t)

    def AsType(self, type):
        return _singa_wrap.Tensor_AsType(self, type)

    def ToDevice(self, dev):
        return _singa_wrap.Tensor_ToDevice(self, dev)

    def ToHost(self):
        return _singa_wrap.Tensor_ToHost(self)

    def L2(self):
        return _singa_wrap.Tensor_L2(self)

    def L1(self):
        return _singa_wrap.Tensor_L1(self)

    def CopyFloatDataFromHostPtr(self, src, num, offset=0):
        return _singa_wrap.Tensor_CopyFloatDataFromHostPtr(self, src, num, offset)

    def CopyIntDataFromHostPtr(self, src, num, offset=0):
        return _singa_wrap.Tensor_CopyIntDataFromHostPtr(self, src, num, offset)

    def CopyData(self, other):
        return _singa_wrap.Tensor_CopyData(self, other)

    def RepeatData(self, repeats, axis, total_repeats, src):
        return _singa_wrap.Tensor_RepeatData(self, repeats, axis, total_repeats, src)

    def Clone(self):
        return _singa_wrap.Tensor_Clone(self)

    def Repeat(self, repeats, axis):
        return _singa_wrap.Tensor_Repeat(self, repeats, axis)

    def __iadd__(self, *args):
        return _singa_wrap.Tensor___iadd__(self, *args)

    def __isub__(self, *args):
        return _singa_wrap.Tensor___isub__(self, *args)

    def __imul__(self, *args):
        return _singa_wrap.Tensor___imul__(self, *args)

    def __idiv__(self, *args):
        return _singa_wrap.Tensor___idiv__(self, *args)
    __swig_destroy__ = _singa_wrap.delete_Tensor
    __del__ = lambda self: None
Tensor_swigregister = _singa_wrap.Tensor_swigregister
Tensor_swigregister(Tensor)


def CopyDataToFrom(dst, src, num, src_offset=0, dst_offset=0):
    return _singa_wrap.CopyDataToFrom(dst, src, num, src_offset, dst_offset)
CopyDataToFrom = _singa_wrap.CopyDataToFrom

def RepeatDataToFrom(broadcast_flag, repeats, axis, dst, src, num):
    return _singa_wrap.RepeatDataToFrom(broadcast_flag, repeats, axis, dst, src, num)
RepeatDataToFrom = _singa_wrap.RepeatDataToFrom

def Reshape(arg1, s):
    return _singa_wrap.Reshape(arg1, s)
Reshape = _singa_wrap.Reshape

def Transpose(arg1, axes):
    return _singa_wrap.Transpose(arg1, axes)
Transpose = _singa_wrap.Transpose

def DefaultTranspose(arg1):
    return _singa_wrap.DefaultTranspose(arg1)
DefaultTranspose = _singa_wrap.DefaultTranspose

def Abs(t):
    return _singa_wrap.Abs(t)
Abs = _singa_wrap.Abs

def Ceil(t):
    return _singa_wrap.Ceil(t)
Ceil = _singa_wrap.Ceil

def Floor(t):
    return _singa_wrap.Floor(t)
Floor = _singa_wrap.Floor

def Exp(t):
    return _singa_wrap.Exp(t)
Exp = _singa_wrap.Exp

def Log(t):
    return _singa_wrap.Log(t)
Log = _singa_wrap.Log

def ReLU(t):
    return _singa_wrap.ReLU(t)
ReLU = _singa_wrap.ReLU

def Sigmoid(t):
    return _singa_wrap.Sigmoid(t)
Sigmoid = _singa_wrap.Sigmoid

def Sign(t):
    return _singa_wrap.Sign(t)
Sign = _singa_wrap.Sign

def Sqrt(t):
    return _singa_wrap.Sqrt(t)
Sqrt = _singa_wrap.Sqrt

def Square(t):
    return _singa_wrap.Square(t)
Square = _singa_wrap.Square

def Cos(t):
    return _singa_wrap.Cos(t)
Cos = _singa_wrap.Cos

def Cosh(t):
    return _singa_wrap.Cosh(t)
Cosh = _singa_wrap.Cosh

def Acos(t):
    return _singa_wrap.Acos(t)
Acos = _singa_wrap.Acos

def Acosh(t):
    return _singa_wrap.Acosh(t)
Acosh = _singa_wrap.Acosh

def Sin(t):
    return _singa_wrap.Sin(t)
Sin = _singa_wrap.Sin

def Sinh(t):
    return _singa_wrap.Sinh(t)
Sinh = _singa_wrap.Sinh

def Asin(t):
    return _singa_wrap.Asin(t)
Asin = _singa_wrap.Asin

def Asinh(t):
    return _singa_wrap.Asinh(t)
Asinh = _singa_wrap.Asinh

def Tan(t):
    return _singa_wrap.Tan(t)
Tan = _singa_wrap.Tan

def Tanh(t):
    return _singa_wrap.Tanh(t)
Tanh = _singa_wrap.Tanh

def Atan(t):
    return _singa_wrap.Atan(t)
Atan = _singa_wrap.Atan

def Atanh(t):
    return _singa_wrap.Atanh(t)
Atanh = _singa_wrap.Atanh

def ReLUBackward(in1, in2):
    return _singa_wrap.ReLUBackward(in1, in2)
ReLUBackward = _singa_wrap.ReLUBackward

def Sum(t, axis):
    return _singa_wrap.Sum(t, axis)
Sum = _singa_wrap.Sum

def SumAsFloat(t):
    return _singa_wrap.SumAsFloat(t)
SumAsFloat = _singa_wrap.SumAsFloat

def SumAll(t):
    return _singa_wrap.SumAll(t)
SumAll = _singa_wrap.SumAll

def Average(t, axis):
    return _singa_wrap.Average(t, axis)
Average = _singa_wrap.Average

def SoftMaxBackward(t, axis, fdout):
    return _singa_wrap.SoftMaxBackward(t, axis, fdout)
SoftMaxBackward = _singa_wrap.SoftMaxBackward

def Pow(base, exp):
    return _singa_wrap.Pow(base, exp)
Pow = _singa_wrap.Pow

def PowWithRet(base, exp, out):
    return _singa_wrap.PowWithRet(base, exp, out)
PowWithRet = _singa_wrap.PowWithRet

def PowFloat(arg1, x):
    return _singa_wrap.PowFloat(arg1, x)
PowFloat = _singa_wrap.PowFloat

def PowFloatWithRet(*args):
    return _singa_wrap.PowFloatWithRet(*args)
PowFloatWithRet = _singa_wrap.PowFloatWithRet

def __lt__(lhs, rhs):
    return _singa_wrap.__lt__(lhs, rhs)
__lt__ = _singa_wrap.__lt__

def __le__(lhs, rhs):
    return _singa_wrap.__le__(lhs, rhs)
__le__ = _singa_wrap.__le__

def __gt__(lhs, rhs):
    return _singa_wrap.__gt__(lhs, rhs)
__gt__ = _singa_wrap.__gt__

def __ge__(lhs, rhs):
    return _singa_wrap.__ge__(lhs, rhs)
__ge__ = _singa_wrap.__ge__

def LTFloat(t, x):
    return _singa_wrap.LTFloat(t, x)
LTFloat = _singa_wrap.LTFloat

def LEFloat(t, x):
    return _singa_wrap.LEFloat(t, x)
LEFloat = _singa_wrap.LEFloat

def GTFloat(t, x):
    return _singa_wrap.GTFloat(t, x)
GTFloat = _singa_wrap.GTFloat

def GEFloat(t, x):
    return _singa_wrap.GEFloat(t, x)
GEFloat = _singa_wrap.GEFloat

def ConcatOn(arg1, axis):
    return _singa_wrap.ConcatOn(arg1, axis)
ConcatOn = _singa_wrap.ConcatOn

def SliceOn(arg1, start, end, axis):
    return _singa_wrap.SliceOn(arg1, start, end, axis)
SliceOn = _singa_wrap.SliceOn

def __add__(lhs, rhs):
    return _singa_wrap.__add__(lhs, rhs)
__add__ = _singa_wrap.__add__

def __sub__(lhs, rhs):
    return _singa_wrap.__sub__(lhs, rhs)
__sub__ = _singa_wrap.__sub__

def __mul__(lhs, rhs):
    return _singa_wrap.__mul__(lhs, rhs)
__mul__ = _singa_wrap.__mul__

def __div__(lhs, rhs):
    return _singa_wrap.__div__(lhs, rhs)
__div__ = _singa_wrap.__div__

def Add(lhs, rhs, ret):
    return _singa_wrap.Add(lhs, rhs, ret)
Add = _singa_wrap.Add

def Sub(lhs, rhs, ret):
    return _singa_wrap.Sub(lhs, rhs, ret)
Sub = _singa_wrap.Sub

def EltwiseMult(lhs, rhs, ret):
    return _singa_wrap.EltwiseMult(lhs, rhs, ret)
EltwiseMult = _singa_wrap.EltwiseMult

def Div(lhs, rhs, ret):
    return _singa_wrap.Div(lhs, rhs, ret)
Div = _singa_wrap.Div

def AddFloat(t, x):
    return _singa_wrap.AddFloat(t, x)
AddFloat = _singa_wrap.AddFloat

def SubFloat(t, x):
    return _singa_wrap.SubFloat(t, x)
SubFloat = _singa_wrap.SubFloat

def MultFloat(t, x):
    return _singa_wrap.MultFloat(t, x)
MultFloat = _singa_wrap.MultFloat

def DivFloat(t, x):
    return _singa_wrap.DivFloat(t, x)
DivFloat = _singa_wrap.DivFloat

def AddFloatWithRet(t, x, ret):
    return _singa_wrap.AddFloatWithRet(t, x, ret)
AddFloatWithRet = _singa_wrap.AddFloatWithRet

def SubFloatWithRet(t, x, ret):
    return _singa_wrap.SubFloatWithRet(t, x, ret)
SubFloatWithRet = _singa_wrap.SubFloatWithRet

def EltwiseMultFloatWithRet(t, x, ret):
    return _singa_wrap.EltwiseMultFloatWithRet(t, x, ret)
EltwiseMultFloatWithRet = _singa_wrap.EltwiseMultFloatWithRet

def DivFloatWithRet(t, x, ret):
    return _singa_wrap.DivFloatWithRet(t, x, ret)
DivFloatWithRet = _singa_wrap.DivFloatWithRet

def Bernoulli(p, out):
    return _singa_wrap.Bernoulli(p, out)
Bernoulli = _singa_wrap.Bernoulli

def Gaussian(mean, std, out):
    return _singa_wrap.Gaussian(mean, std, out)
Gaussian = _singa_wrap.Gaussian

def Uniform(low, high, out):
    return _singa_wrap.Uniform(low, high, out)
Uniform = _singa_wrap.Uniform

def Axpy(*args):
    return _singa_wrap.Axpy(*args)
Axpy = _singa_wrap.Axpy

def Mult(A, B):
    return _singa_wrap.Mult(A, B)
Mult = _singa_wrap.Mult

def MultWithRet(A, B, C):
    return _singa_wrap.MultWithRet(A, B, C)
MultWithRet = _singa_wrap.MultWithRet

def MultWithScale(alpha, A, B, beta, C):
    return _singa_wrap.MultWithScale(alpha, A, B, beta, C)
MultWithScale = _singa_wrap.MultWithScale

def AddColumn(v, M):
    return _singa_wrap.AddColumn(v, M)
AddColumn = _singa_wrap.AddColumn

def AddColumnWithScale(alpha, beta, v, M):
    return _singa_wrap.AddColumnWithScale(alpha, beta, v, M)
AddColumnWithScale = _singa_wrap.AddColumnWithScale

def AddRow(v, M):
    return _singa_wrap.AddRow(v, M)
AddRow = _singa_wrap.AddRow

def AddRowWithScale(alpha, beta, v, M):
    return _singa_wrap.AddRowWithScale(alpha, beta, v, M)
AddRowWithScale = _singa_wrap.AddRowWithScale

def DivColumn(v, M):
    return _singa_wrap.DivColumn(v, M)
DivColumn = _singa_wrap.DivColumn

def DivRow(v, M):
    return _singa_wrap.DivRow(v, M)
DivRow = _singa_wrap.DivRow

def MultColumn(v, M):
    return _singa_wrap.MultColumn(v, M)
MultColumn = _singa_wrap.MultColumn

def MultRow(v, M):
    return _singa_wrap.MultRow(v, M)
MultRow = _singa_wrap.MultRow

def SubColumn(v, M):
    return _singa_wrap.SubColumn(v, M)
SubColumn = _singa_wrap.SubColumn

def SubRow(v, M):
    return _singa_wrap.SubRow(v, M)
SubRow = _singa_wrap.SubRow

def SumColumns(M, v):
    return _singa_wrap.SumColumns(M, v)
SumColumns = _singa_wrap.SumColumns

def SumRows(M, v):
    return _singa_wrap.SumRows(M, v)
SumRows = _singa_wrap.SumRows

def SoftMax(*args):
    return _singa_wrap.SoftMax(*args)
SoftMax = _singa_wrap.SoftMax

def CrossEntropyFwd(p, t):
    return _singa_wrap.CrossEntropyFwd(p, t)
CrossEntropyFwd = _singa_wrap.CrossEntropyFwd

def SoftmaxCrossEntropyBwd(p, t):
    return _singa_wrap.SoftmaxCrossEntropyBwd(p, t)
SoftmaxCrossEntropyBwd = _singa_wrap.SoftmaxCrossEntropyBwd
class PairSizeT(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairSizeT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairSizeT, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _singa_wrap.new_PairSizeT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _singa_wrap.PairSizeT_first_set
    __swig_getmethods__["first"] = _singa_wrap.PairSizeT_first_get
    if _newclass:
        first = _swig_property(_singa_wrap.PairSizeT_first_get, _singa_wrap.PairSizeT_first_set)
    __swig_setmethods__["second"] = _singa_wrap.PairSizeT_second_set
    __swig_getmethods__["second"] = _singa_wrap.PairSizeT_second_get
    if _newclass:
        second = _swig_property(_singa_wrap.PairSizeT_second_get, _singa_wrap.PairSizeT_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _singa_wrap.delete_PairSizeT
    __del__ = lambda self: None
PairSizeT_swigregister = _singa_wrap.PairSizeT_swigregister
PairSizeT_swigregister(PairSizeT)

class VecPairSizeT(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecPairSizeT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VecPairSizeT, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _singa_wrap.VecPairSizeT_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _singa_wrap.VecPairSizeT___nonzero__(self)

    def __bool__(self):
        return _singa_wrap.VecPairSizeT___bool__(self)

    def __len__(self):
        return _singa_wrap.VecPairSizeT___len__(self)

    def __getslice__(self, i, j):
        return _singa_wrap.VecPairSizeT___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _singa_wrap.VecPairSizeT___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _singa_wrap.VecPairSizeT___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _singa_wrap.VecPairSizeT___delitem__(self, *args)

    def __getitem__(self, *args):
        return _singa_wrap.VecPairSizeT___getitem__(self, *args)

    def __setitem__(self, *args):
        return _singa_wrap.VecPairSizeT___setitem__(self, *args)

    def pop(self):
        return _singa_wrap.VecPairSizeT_pop(self)

    def append(self, x):
        return _singa_wrap.VecPairSizeT_append(self, x)

    def empty(self):
        return _singa_wrap.VecPairSizeT_empty(self)

    def size(self):
        return _singa_wrap.VecPairSizeT_size(self)

    def swap(self, v):
        return _singa_wrap.VecPairSizeT_swap(self, v)

    def begin(self):
        return _singa_wrap.VecPairSizeT_begin(self)

    def end(self):
        return _singa_wrap.VecPairSizeT_end(self)

    def rbegin(self):
        return _singa_wrap.VecPairSizeT_rbegin(self)

    def rend(self):
        return _singa_wrap.VecPairSizeT_rend(self)

    def clear(self):
        return _singa_wrap.VecPairSizeT_clear(self)

    def get_allocator(self):
        return _singa_wrap.VecPairSizeT_get_allocator(self)

    def pop_back(self):
        return _singa_wrap.VecPairSizeT_pop_back(self)

    def erase(self, *args):
        return _singa_wrap.VecPairSizeT_erase(self, *args)

    def __init__(self, *args):
        this = _singa_wrap.new_VecPairSizeT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _singa_wrap.VecPairSizeT_push_back(self, x)

    def front(self):
        return _singa_wrap.VecPairSizeT_front(self)

    def back(self):
        return _singa_wrap.VecPairSizeT_back(self)

    def assign(self, n, x):
        return _singa_wrap.VecPairSizeT_assign(self, n, x)

    def resize(self, *args):
        return _singa_wrap.VecPairSizeT_resize(self, *args)

    def insert(self, *args):
        return _singa_wrap.VecPairSizeT_insert(self, *args)

    def reserve(self, n):
        return _singa_wrap.VecPairSizeT_reserve(self, n)

    def capacity(self):
        return _singa_wrap.VecPairSizeT_capacity(self)
    __swig_destroy__ = _singa_wrap.delete_VecPairSizeT
    __del__ = lambda self: None
VecPairSizeT_swigregister = _singa_wrap.VecPairSizeT_swigregister
VecPairSizeT_swigregister(VecPairSizeT)

class VecSharedPtrDevice(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecSharedPtrDevice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VecSharedPtrDevice, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _singa_wrap.VecSharedPtrDevice_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _singa_wrap.VecSharedPtrDevice___nonzero__(self)

    def __bool__(self):
        return _singa_wrap.VecSharedPtrDevice___bool__(self)

    def __len__(self):
        return _singa_wrap.VecSharedPtrDevice___len__(self)

    def __getslice__(self, i, j):
        return _singa_wrap.VecSharedPtrDevice___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _singa_wrap.VecSharedPtrDevice___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _singa_wrap.VecSharedPtrDevice___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _singa_wrap.VecSharedPtrDevice___delitem__(self, *args)

    def __getitem__(self, *args):
        return _singa_wrap.VecSharedPtrDevice___getitem__(self, *args)

    def __setitem__(self, *args):
        return _singa_wrap.VecSharedPtrDevice___setitem__(self, *args)

    def pop(self):
        return _singa_wrap.VecSharedPtrDevice_pop(self)

    def append(self, x):
        return _singa_wrap.VecSharedPtrDevice_append(self, x)

    def empty(self):
        return _singa_wrap.VecSharedPtrDevice_empty(self)

    def size(self):
        return _singa_wrap.VecSharedPtrDevice_size(self)

    def swap(self, v):
        return _singa_wrap.VecSharedPtrDevice_swap(self, v)

    def begin(self):
        return _singa_wrap.VecSharedPtrDevice_begin(self)

    def end(self):
        return _singa_wrap.VecSharedPtrDevice_end(self)

    def rbegin(self):
        return _singa_wrap.VecSharedPtrDevice_rbegin(self)

    def rend(self):
        return _singa_wrap.VecSharedPtrDevice_rend(self)

    def clear(self):
        return _singa_wrap.VecSharedPtrDevice_clear(self)

    def get_allocator(self):
        return _singa_wrap.VecSharedPtrDevice_get_allocator(self)

    def pop_back(self):
        return _singa_wrap.VecSharedPtrDevice_pop_back(self)

    def erase(self, *args):
        return _singa_wrap.VecSharedPtrDevice_erase(self, *args)

    def __init__(self, *args):
        this = _singa_wrap.new_VecSharedPtrDevice(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _singa_wrap.VecSharedPtrDevice_push_back(self, x)

    def front(self):
        return _singa_wrap.VecSharedPtrDevice_front(self)

    def back(self):
        return _singa_wrap.VecSharedPtrDevice_back(self)

    def assign(self, n, x):
        return _singa_wrap.VecSharedPtrDevice_assign(self, n, x)

    def resize(self, *args):
        return _singa_wrap.VecSharedPtrDevice_resize(self, *args)

    def insert(self, *args):
        return _singa_wrap.VecSharedPtrDevice_insert(self, *args)

    def reserve(self, n):
        return _singa_wrap.VecSharedPtrDevice_reserve(self, n)

    def capacity(self):
        return _singa_wrap.VecSharedPtrDevice_capacity(self)
    __swig_destroy__ = _singa_wrap.delete_VecSharedPtrDevice
    __del__ = lambda self: None
VecSharedPtrDevice_swigregister = _singa_wrap.VecSharedPtrDevice_swigregister
VecSharedPtrDevice_swigregister(VecSharedPtrDevice)

class VecInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VecInt, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _singa_wrap.VecInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _singa_wrap.VecInt___nonzero__(self)

    def __bool__(self):
        return _singa_wrap.VecInt___bool__(self)

    def __len__(self):
        return _singa_wrap.VecInt___len__(self)

    def __getslice__(self, i, j):
        return _singa_wrap.VecInt___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _singa_wrap.VecInt___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _singa_wrap.VecInt___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _singa_wrap.VecInt___delitem__(self, *args)

    def __getitem__(self, *args):
        return _singa_wrap.VecInt___getitem__(self, *args)

    def __setitem__(self, *args):
        return _singa_wrap.VecInt___setitem__(self, *args)

    def pop(self):
        return _singa_wrap.VecInt_pop(self)

    def append(self, x):
        return _singa_wrap.VecInt_append(self, x)

    def empty(self):
        return _singa_wrap.VecInt_empty(self)

    def size(self):
        return _singa_wrap.VecInt_size(self)

    def swap(self, v):
        return _singa_wrap.VecInt_swap(self, v)

    def begin(self):
        return _singa_wrap.VecInt_begin(self)

    def end(self):
        return _singa_wrap.VecInt_end(self)

    def rbegin(self):
        return _singa_wrap.VecInt_rbegin(self)

    def rend(self):
        return _singa_wrap.VecInt_rend(self)

    def clear(self):
        return _singa_wrap.VecInt_clear(self)

    def get_allocator(self):
        return _singa_wrap.VecInt_get_allocator(self)

    def pop_back(self):
        return _singa_wrap.VecInt_pop_back(self)

    def erase(self, *args):
        return _singa_wrap.VecInt_erase(self, *args)

    def __init__(self, *args):
        this = _singa_wrap.new_VecInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _singa_wrap.VecInt_push_back(self, x)

    def front(self):
        return _singa_wrap.VecInt_front(self)

    def back(self):
        return _singa_wrap.VecInt_back(self)

    def assign(self, n, x):
        return _singa_wrap.VecInt_assign(self, n, x)

    def resize(self, *args):
        return _singa_wrap.VecInt_resize(self, *args)

    def insert(self, *args):
        return _singa_wrap.VecInt_insert(self, *args)

    def reserve(self, n):
        return _singa_wrap.VecInt_reserve(self, n)

    def capacity(self):
        return _singa_wrap.VecInt_capacity(self)
    __swig_destroy__ = _singa_wrap.delete_VecInt
    __del__ = lambda self: None
VecInt_swigregister = _singa_wrap.VecInt_swigregister
VecInt_swigregister(VecInt)

class Device(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Device, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Device, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetRandSeed(self, seed):
        return _singa_wrap.Device_SetRandSeed(self, seed)

    def host(self):
        return _singa_wrap.Device_host(self)

    def id(self):
        return _singa_wrap.Device_id(self)

    def Sync(self):
        return _singa_wrap.Device_Sync(self)

    def ResetGraph(self):
        return _singa_wrap.Device_ResetGraph(self)

    def RunGraph(self, serial=False):
        return _singa_wrap.Device_RunGraph(self, serial)

    def graph_enabled(self):
        return _singa_wrap.Device_graph_enabled(self)

    def EnableGraph(self, enable):
        return _singa_wrap.Device_EnableGraph(self, enable)

    def PrintTimeProfiling(self):
        return _singa_wrap.Device_PrintTimeProfiling(self)

    def SetVerbosity(self, verbosity):
        return _singa_wrap.Device_SetVerbosity(self, verbosity)

    def SetSkipIteration(self, skip_iteration):
        return _singa_wrap.Device_SetSkipIteration(self, skip_iteration)
    if _newclass:
        EnableLazyAlloc = staticmethod(_singa_wrap.Device_EnableLazyAlloc)
    else:
        EnableLazyAlloc = _singa_wrap.Device_EnableLazyAlloc
    __swig_destroy__ = _singa_wrap.delete_Device
    __del__ = lambda self: None
Device_swigregister = _singa_wrap.Device_swigregister
Device_swigregister(Device)

def Device_EnableLazyAlloc(enbale):
    return _singa_wrap.Device_EnableLazyAlloc(enbale)
Device_EnableLazyAlloc = _singa_wrap.Device_EnableLazyAlloc

class Platform(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Platform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Platform, name)
    __repr__ = _swig_repr
    if _newclass:
        GetDefaultDevice = staticmethod(_singa_wrap.Platform_GetDefaultDevice)
    else:
        GetDefaultDevice = _singa_wrap.Platform_GetDefaultDevice

    def __init__(self):
        this = _singa_wrap.new_Platform()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _singa_wrap.delete_Platform
    __del__ = lambda self: None
Platform_swigregister = _singa_wrap.Platform_swigregister
Platform_swigregister(Platform)

def Platform_GetDefaultDevice():
    return _singa_wrap.Platform_GetDefaultDevice()
Platform_GetDefaultDevice = _singa_wrap.Platform_GetDefaultDevice

class ConvHandle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConvHandle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConvHandle, name)
    __repr__ = _swig_repr

    def __init__(self, input, kernel_size, stride, padding, in_channels, out_channels, bias, groups):
        this = _singa_wrap.new_ConvHandle(input, kernel_size, stride, padding, in_channels, out_channels, bias, groups)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["bias_term"] = _singa_wrap.ConvHandle_bias_term_set
    __swig_getmethods__["bias_term"] = _singa_wrap.ConvHandle_bias_term_get
    if _newclass:
        bias_term = _swig_property(_singa_wrap.ConvHandle_bias_term_get, _singa_wrap.ConvHandle_bias_term_set)
    __swig_setmethods__["batchsize"] = _singa_wrap.ConvHandle_batchsize_set
    __swig_getmethods__["batchsize"] = _singa_wrap.ConvHandle_batchsize_get
    if _newclass:
        batchsize = _swig_property(_singa_wrap.ConvHandle_batchsize_get, _singa_wrap.ConvHandle_batchsize_set)
    __swig_setmethods__["pad_w"] = _singa_wrap.ConvHandle_pad_w_set
    __swig_getmethods__["pad_w"] = _singa_wrap.ConvHandle_pad_w_get
    if _newclass:
        pad_w = _swig_property(_singa_wrap.ConvHandle_pad_w_get, _singa_wrap.ConvHandle_pad_w_set)
    __swig_setmethods__["pad_h"] = _singa_wrap.ConvHandle_pad_h_set
    __swig_getmethods__["pad_h"] = _singa_wrap.ConvHandle_pad_h_get
    if _newclass:
        pad_h = _swig_property(_singa_wrap.ConvHandle_pad_h_get, _singa_wrap.ConvHandle_pad_h_set)
    __swig_setmethods__["stride_h"] = _singa_wrap.ConvHandle_stride_h_set
    __swig_getmethods__["stride_h"] = _singa_wrap.ConvHandle_stride_h_get
    if _newclass:
        stride_h = _swig_property(_singa_wrap.ConvHandle_stride_h_get, _singa_wrap.ConvHandle_stride_h_set)
    __swig_setmethods__["stride_w"] = _singa_wrap.ConvHandle_stride_w_set
    __swig_getmethods__["stride_w"] = _singa_wrap.ConvHandle_stride_w_get
    if _newclass:
        stride_w = _swig_property(_singa_wrap.ConvHandle_stride_w_get, _singa_wrap.ConvHandle_stride_w_set)
    __swig_setmethods__["kernel_h"] = _singa_wrap.ConvHandle_kernel_h_set
    __swig_getmethods__["kernel_h"] = _singa_wrap.ConvHandle_kernel_h_get
    if _newclass:
        kernel_h = _swig_property(_singa_wrap.ConvHandle_kernel_h_get, _singa_wrap.ConvHandle_kernel_h_set)
    __swig_setmethods__["kernel_w"] = _singa_wrap.ConvHandle_kernel_w_set
    __swig_getmethods__["kernel_w"] = _singa_wrap.ConvHandle_kernel_w_get
    if _newclass:
        kernel_w = _swig_property(_singa_wrap.ConvHandle_kernel_w_get, _singa_wrap.ConvHandle_kernel_w_set)
    __swig_setmethods__["channels"] = _singa_wrap.ConvHandle_channels_set
    __swig_getmethods__["channels"] = _singa_wrap.ConvHandle_channels_get
    if _newclass:
        channels = _swig_property(_singa_wrap.ConvHandle_channels_get, _singa_wrap.ConvHandle_channels_set)
    __swig_setmethods__["num_filters"] = _singa_wrap.ConvHandle_num_filters_set
    __swig_getmethods__["num_filters"] = _singa_wrap.ConvHandle_num_filters_get
    if _newclass:
        num_filters = _swig_property(_singa_wrap.ConvHandle_num_filters_get, _singa_wrap.ConvHandle_num_filters_set)
    __swig_setmethods__["group"] = _singa_wrap.ConvHandle_group_set
    __swig_getmethods__["group"] = _singa_wrap.ConvHandle_group_get
    if _newclass:
        group = _swig_property(_singa_wrap.ConvHandle_group_get, _singa_wrap.ConvHandle_group_set)
    __swig_destroy__ = _singa_wrap.delete_ConvHandle
    __del__ = lambda self: None
ConvHandle_swigregister = _singa_wrap.ConvHandle_swigregister
ConvHandle_swigregister(ConvHandle)


def CpuConvForward(x, W, b, ch):
    return _singa_wrap.CpuConvForward(x, W, b, ch)
CpuConvForward = _singa_wrap.CpuConvForward

def CpuConvBackwardx(dy, W, x, ch):
    return _singa_wrap.CpuConvBackwardx(dy, W, x, ch)
CpuConvBackwardx = _singa_wrap.CpuConvBackwardx

def CpuConvBackwardW(dy, x, W, ch):
    return _singa_wrap.CpuConvBackwardW(dy, x, W, ch)
CpuConvBackwardW = _singa_wrap.CpuConvBackwardW

def CpuConvBackwardb(dy, b, ch):
    return _singa_wrap.CpuConvBackwardb(dy, b, ch)
CpuConvBackwardb = _singa_wrap.CpuConvBackwardb
class BatchNormHandle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BatchNormHandle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BatchNormHandle, name)
    __repr__ = _swig_repr

    def __init__(self, momentum, input):
        this = _singa_wrap.new_BatchNormHandle(momentum, input)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["batchsize"] = _singa_wrap.BatchNormHandle_batchsize_set
    __swig_getmethods__["batchsize"] = _singa_wrap.BatchNormHandle_batchsize_get
    if _newclass:
        batchsize = _swig_property(_singa_wrap.BatchNormHandle_batchsize_get, _singa_wrap.BatchNormHandle_batchsize_set)
    __swig_setmethods__["factor"] = _singa_wrap.BatchNormHandle_factor_set
    __swig_getmethods__["factor"] = _singa_wrap.BatchNormHandle_factor_get
    if _newclass:
        factor = _swig_property(_singa_wrap.BatchNormHandle_factor_get, _singa_wrap.BatchNormHandle_factor_set)
    __swig_destroy__ = _singa_wrap.delete_BatchNormHandle
    __del__ = lambda self: None
BatchNormHandle_swigregister = _singa_wrap.BatchNormHandle_swigregister
BatchNormHandle_swigregister(BatchNormHandle)


def CpuBatchNormForwardInference(bnh, x, bnScale, bnBias, running_mean, running_var):
    return _singa_wrap.CpuBatchNormForwardInference(bnh, x, bnScale, bnBias, running_mean, running_var)
CpuBatchNormForwardInference = _singa_wrap.CpuBatchNormForwardInference

def CpuBatchNormForwardTraining(bnh, x, bnScale, bnBias, running_mean, running_var):
    return _singa_wrap.CpuBatchNormForwardTraining(bnh, x, bnScale, bnBias, running_mean, running_var)
CpuBatchNormForwardTraining = _singa_wrap.CpuBatchNormForwardTraining

def CpuBatchNormBackwardx(bnh, y, dy, x, bnScale, bnBias, mean, var):
    return _singa_wrap.CpuBatchNormBackwardx(bnh, y, dy, x, bnScale, bnBias, mean, var)
CpuBatchNormBackwardx = _singa_wrap.CpuBatchNormBackwardx
class PoolingHandle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PoolingHandle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PoolingHandle, name)
    __repr__ = _swig_repr

    def __init__(self, input, kernel_size, stride, padding, is_max=True):
        this = _singa_wrap.new_PoolingHandle(input, kernel_size, stride, padding, is_max)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["batchsize"] = _singa_wrap.PoolingHandle_batchsize_set
    __swig_getmethods__["batchsize"] = _singa_wrap.PoolingHandle_batchsize_get
    if _newclass:
        batchsize = _swig_property(_singa_wrap.PoolingHandle_batchsize_get, _singa_wrap.PoolingHandle_batchsize_set)
    __swig_setmethods__["stride_h"] = _singa_wrap.PoolingHandle_stride_h_set
    __swig_getmethods__["stride_h"] = _singa_wrap.PoolingHandle_stride_h_get
    if _newclass:
        stride_h = _swig_property(_singa_wrap.PoolingHandle_stride_h_get, _singa_wrap.PoolingHandle_stride_h_set)
    __swig_setmethods__["stride_w"] = _singa_wrap.PoolingHandle_stride_w_set
    __swig_getmethods__["stride_w"] = _singa_wrap.PoolingHandle_stride_w_get
    if _newclass:
        stride_w = _swig_property(_singa_wrap.PoolingHandle_stride_w_get, _singa_wrap.PoolingHandle_stride_w_set)
    __swig_setmethods__["kernel_h"] = _singa_wrap.PoolingHandle_kernel_h_set
    __swig_getmethods__["kernel_h"] = _singa_wrap.PoolingHandle_kernel_h_get
    if _newclass:
        kernel_h = _swig_property(_singa_wrap.PoolingHandle_kernel_h_get, _singa_wrap.PoolingHandle_kernel_h_set)
    __swig_setmethods__["kernel_w"] = _singa_wrap.PoolingHandle_kernel_w_set
    __swig_getmethods__["kernel_w"] = _singa_wrap.PoolingHandle_kernel_w_get
    if _newclass:
        kernel_w = _swig_property(_singa_wrap.PoolingHandle_kernel_w_get, _singa_wrap.PoolingHandle_kernel_w_set)
    __swig_setmethods__["pad_h"] = _singa_wrap.PoolingHandle_pad_h_set
    __swig_getmethods__["pad_h"] = _singa_wrap.PoolingHandle_pad_h_get
    if _newclass:
        pad_h = _swig_property(_singa_wrap.PoolingHandle_pad_h_get, _singa_wrap.PoolingHandle_pad_h_set)
    __swig_setmethods__["pad_w"] = _singa_wrap.PoolingHandle_pad_w_set
    __swig_getmethods__["pad_w"] = _singa_wrap.PoolingHandle_pad_w_get
    if _newclass:
        pad_w = _swig_property(_singa_wrap.PoolingHandle_pad_w_get, _singa_wrap.PoolingHandle_pad_w_set)
    __swig_setmethods__["pooled_height"] = _singa_wrap.PoolingHandle_pooled_height_set
    __swig_getmethods__["pooled_height"] = _singa_wrap.PoolingHandle_pooled_height_get
    if _newclass:
        pooled_height = _swig_property(_singa_wrap.PoolingHandle_pooled_height_get, _singa_wrap.PoolingHandle_pooled_height_set)
    __swig_setmethods__["pooled_width"] = _singa_wrap.PoolingHandle_pooled_width_set
    __swig_getmethods__["pooled_width"] = _singa_wrap.PoolingHandle_pooled_width_get
    if _newclass:
        pooled_width = _swig_property(_singa_wrap.PoolingHandle_pooled_width_get, _singa_wrap.PoolingHandle_pooled_width_set)
    __swig_setmethods__["is_max_pooling"] = _singa_wrap.PoolingHandle_is_max_pooling_set
    __swig_getmethods__["is_max_pooling"] = _singa_wrap.PoolingHandle_is_max_pooling_get
    if _newclass:
        is_max_pooling = _swig_property(_singa_wrap.PoolingHandle_is_max_pooling_get, _singa_wrap.PoolingHandle_is_max_pooling_set)
    __swig_destroy__ = _singa_wrap.delete_PoolingHandle
    __del__ = lambda self: None
PoolingHandle_swigregister = _singa_wrap.PoolingHandle_swigregister
PoolingHandle_swigregister(PoolingHandle)


def CpuPoolingForward(ph, x):
    return _singa_wrap.CpuPoolingForward(ph, x)
CpuPoolingForward = _singa_wrap.CpuPoolingForward

def CpuPoolingBackward(ph, dy, x, y):
    return _singa_wrap.CpuPoolingBackward(ph, dy, x, y)
CpuPoolingBackward = _singa_wrap.CpuPoolingBackward
# This file is compatible with both classic and new-style classes.


